= ConnectionFactory configuration

Without going into that many details as in <<datasource-configuration,DataSource configuration chapter>>, we'll
present how JMS connection factories may be used in OSGi.

Fundamentally, it's done using:

[source, java, options="nowrap"]
----
org.osgi.framework.BundleContext.registerService(javax.jms.ConnectionFactory.class,
                                                 connectionFactoryObject,
                                                 properties);
org.osgi.framework.BundleContext.registerService(javax.jms.XAConnectionFactory.class,
                                                 xaConnectionFactoryObject,
                                                 properties);
----

There are two different methods to register such services:

* publishing connection factories using `jms:create` Karaf console command. We can call it _configuration method_.

* publishing connection factories using methods like Blueprint, OSGi Declarative Services (SCR) or just
`BundleContext.registerService()` API call. This method requires dedicated OSGi bundle that contains the code and/or
metadata. We can call it _deployment method_.

== OSGi JMS Service

OSGi way of handling JDBC data sources is related to two interfaces:

* _standard_ `org.osgi.service.jdbc.DataSourceFactory`
* _proprietary_ `org.ops4j.pax.jdbc.pool.common.PooledDataSourceFactory`

For JMS we have these analogies:

* _proprietary_ `org.ops4j.pax.jms.service.ConnectionFactoryFactory` with the same purpose as _standard_ OSGi JDBC `org.osgi.service.jdbc.DataSourceFactory`
* _proprietary_ `org.ops4j.pax.jms.service.PooledConnectionFactoryFactory` with the same purpose as _proprietary_ pax-jdbc `org.ops4j.pax.jdbc.pool.common.PooledDataSourceFactory`

.Dedicated, broker-specific org.ops4j.pax.jms.service.ConnectionFactoryFactory implementations

There are bundles like:

* `mvn:org.ops4j.pax.jms/pax-jms-activemq/1.0.7`
* `mvn:org.ops4j.pax.jms/pax-jms-artemis/1.0.7`
* `mvn:org.ops4j.pax.jms/pax-jms-ibmmq/1.0.7`

that register broker-specific `org.ops4j.pax.jms.service.ConnectionFactoryFactory` services that can return
JMS _factories_ (`javax.jms.ConnectionFactory` and `javax.jms.XAConnectionFactory`). For example:

[literal, options="nowrap"]
----
karaf@root()> feature:install pax-jms-config
karaf@root()> feature:install pax-jms-artemis

karaf@root()> bundle:services -p org.ops4j.pax.jms.pax-jms-config

OPS4J Pax JMS Config (267) provides:
------------------------------------
objectClass = [org.osgi.service.cm.ManagedServiceFactory]
service.bundleid = 267
service.id = 321
service.pid = org.ops4j.connectionfactory
service.scope = singleton

karaf@root()> bundle:services -p org.ops4j.pax.jms.pax-jms-artemis

OPS4J Pax JMS Artemis Support (293) provides:
---------------------------------------------
objectClass = [org.ops4j.pax.jms.service.ConnectionFactoryFactory]
service.bundleid = 293
service.id = 350
service.scope = singleton
type = artemis
----

[[pax-jms-config]]
== PAX-JMS configuration service

`mvn:org.ops4j.pax.jms/pax-jms-config/1.0.7` bundle provides a Managed Service Factory
that does two things:

* tracks `org.ops4j.pax.jms.service.ConnectionFactoryFactory` OSGi services in order to invoke its methods:
+
[source,java,options="nowrap"]
....
public ConnectionFactory createConnectionFactory(Map<String, Object> properties);

public XAConnectionFactory createXAConnectionFactory(Map<String, Object> properties);
....

* tracks `org.ops4j.connectionfactory` _factory PIDs_ in order to collect properties required by the above methods.
If we create a _factory configuration_ using any method available for Configuration Admin service, for example by
creating `${karaf.etc}/org.ops4j.connectionfactory-activemq.cfg` file, we can perform the final step to expose actual
broker-specific connection factory.

[[canonical-pax-jms-config-example]]
Here's the detailed, _canonical_ step-by-step guide.

. Install Artemis driver (simplest way is to use `pax-jms-artemis` feature) and `pax-jms-config` features:
+
[listing,options="nowrap"]
----
karaf@root()> feature:install pax-jms-config
karaf@root()> feature:install pax-jms-artemis

karaf@root()> bundle:services -p org.ops4j.pax.jms.pax-jms-config

OPS4J Pax JMS Config (267) provides:
------------------------------------
objectClass = [org.osgi.service.cm.ManagedServiceFactory]
service.bundleid = 267
service.id = 321
service.pid = org.ops4j.connectionfactory
service.scope = singleton

karaf@root()> bundle:services -p org.ops4j.pax.jms.pax-jms-artemis

OPS4J Pax JMS Artemis Support (293) provides:
---------------------------------------------
objectClass = [org.ops4j.pax.jms.service.ConnectionFactoryFactory]
service.bundleid = 293
service.id = 350
service.scope = singleton
type = artemis
----

. Create _factory configuration_:
+
[listing,options="nowrap"]
----
karaf@root()> config:edit --factory --alias artemis org.ops4j.connectionfactory
karaf@root()> config:property-set type artemis
karaf@root()> config:property-set osgi.jndi.service.name jms/artemis # "name" property may be used too
karaf@root()> config:property-set connectionFactoryType ConnectionFactory # or XAConnectionFactory
karaf@root()> config:property-set jms.url tcp://localhost:61616
karaf@root()> config:property-set jms.user fuse
karaf@root()> config:property-set jms.password fuse
karaf@root()> config:property-set jms.consumerMaxRate 1234
karaf@root()> config:update

karaf@root()> config:list '(service.factoryPid=org.ops4j.connectionfactory)'
----------------------------------------------------------------
Pid:            org.ops4j.connectionfactory.ddd2b703-92b3-4653-b5ff-7d4477f2890c
FactoryPid:     org.ops4j.connectionfactory
BundleLocation: ?
Properties:
   connectionFactoryType = ConnectionFactory
   felix.fileinstall.filename = file:${karaf.etc}/org.ops4j.connectionfactory-artemis.cfg
   jms.consumerMaxRate = 1234
   jms.password = fuse
   jms.url = tcp://localhost:61616
   jms.user = fuse
   osgi.jndi.service.name = jms/artemis
   service.factoryPid = org.ops4j.connectionfactory
   service.pid = org.ops4j.connectionfactory.ddd2b703-92b3-4653-b5ff-7d4477f2890c
   type = artemis
----
+
NOTE: If we specify additional for Artemis configuration - `protocol=amqp`, QPID JMS library would be used instead of Artemis JMS client.
`amqp://` protocol has to be used then for `jms.url` property.

. Check if `pax-jms-config` processed the configuration into `javax.jms.ConnectionFactory` service:
+
[listing,options="nowrap"]
----
karaf@root()> service:list javax.jms.ConnectionFactory
[javax.jms.ConnectionFactory]
-----------------------------
 connectionFactoryType = ConnectionFactory
 felix.fileinstall.filename = file:${karaf.etc}/org.ops4j.connectionfactory-artemis.cfg
 jms.consumerMaxRate = 1234
 jms.password = fuse
 jms.url = tcp://localhost:61616
 jms.user = fuse
 osgi.jndi.service.name = jms/artemis
 pax.jms.managed = true
 service.bundleid = 267
 service.factoryPid = org.ops4j.connectionfactory
 service.id = 607
 service.pid = org.ops4j.connectionfactory.ddd2b703-92b3-4653-b5ff-7d4477f2890c
 service.scope = singleton
 type = artemis
Provided by :
 OPS4J Pax JMS Config (267)
----

Now we have actual broker-specific (no pooling yet) connection factory. We can already inject it where needed. For example we can
use Karaf commands from `jms` feature:
[listing,options="nowrap"]
----
karaf@root()> feature:install -v jms
Adding features: jms/[4.2.9.fuse-780015,4.2.9.fuse-780015]
...
karaf@root()> jms:connectionfactories
JMS Connection Factory
──────────────────────
jms/artemis

karaf@root()> jms:info -u fuse -p fuse jms/artemis
Property │ Value
─────────┼────────────────────
product  │ ActiveMQ
version  │ 2.13.0.redhat-00006

karaf@root()> jms:send -u fuse -p fuse jms/artemis DEV.QUEUE.1 "Hello Artemis from PAX-JMS"

karaf@root()> jms:browse -u fuse -p fuse jms/artemis DEV.QUEUE.1
Message ID                              │ Content                    │ Charset │ Type │ Correlation ID │ Delivery Mode │ Destination                │ Expiration │ Priority │ Redelivered │ ReplyTo │ Timestamp
────────────────────────────────────────┼────────────────────────────┼─────────┼──────┼────────────────┼───────────────┼────────────────────────────┼────────────┼──────────┼─────────────┼─────────┼──────────────────────────────
ID:ae8d70aa-12ce-11eb-895a-54e1ad3055fb │ Hello Artemis from PAX-JMS │ UTF-8   │      │                │ Persistent    │ ActiveMQQueue[DEV.QUEUE.1] │ Never      │ 4        │ false       │         │ Tue Oct 20 14:20:46 CEST 2020
----

Let's switch the protocol:
[listing,options="nowrap"]
----
karaf@root()> config:list '(service.factoryPid=org.ops4j.connectionfactory)'
----------------------------------------------------------------
Pid:            org.ops4j.connectionfactory.ddd2b703-92b3-4653-b5ff-7d4477f2890c
FactoryPid:     org.ops4j.connectionfactory
BundleLocation: ?
Properties:
   connectionFactoryType = ConnectionFactory
   felix.fileinstall.filename = file:${karaf.etc}/org.ops4j.connectionfactory-artemis.cfg
   jms.consumerMaxRate = 1234
   jms.password = fuse
   jms.url = tcp://localhost:61616
   jms.user = fuse
   osgi.jndi.service.name = jms/artemis
   service.factoryPid = org.ops4j.connectionfactory
   service.pid = org.ops4j.connectionfactory.ddd2b703-92b3-4653-b5ff-7d4477f2890c
   type = artemis

karaf@root()> config:edit org.ops4j.connectionfactory.312eb09a-d686-4229-b7e1-2ea38a77bb0f
karaf@root()> config:property-set protocol amqp
karaf@root()> config:property-delete user
karaf@root()> config:property-set username fuse # mind the difference between artemis-jms-client and qpid-jms-client
karaf@root()> config:property-set jms.url amqp://localhost:61616
karaf@root()> config:update

karaf@root()> jms:info -u fuse -p fuse jms/artemis
Property │ Value
─────────┼────────────────────
product  │ QpidJMS
version  │ 0.51.0.redhat-00002
----

[[ibmmq-osgi-package]]
For completeness, let's see how we can connect to IBM MQ 9. Even if `pax-jms-ibmmq` installs relevant `pax-jms`
bundles, IBM MQ driver is not installed due to licensing reasons.

As mentioned in <<ibm-mq,chapter about IBM MQ>>, we can download drivers from https://developer.ibm.com/messaging/mq-downloads/[IBM MQ page].
`OSGi` directory of `9.1.0.6-IBM-MQ-Install-Java-All.jar` package contains only two bundles:

* `com.ibm.mq.osgi.allclient_9.1.0.6.jar` - actual driver
* `com.ibm.mq.osgi.allclientprereqs_9.1.0.6.jar` - preprequisites

While the prerequisites JAR contain required `fscontext.jar` and `providerutil.jar` libraries, it also contains:

* `bcprov-jdk15on.jar` and `bcpkix-jdk15on.jar`, while {f7} ships those (in newer version) in `$FUSE_HOME/lib/ext`
* `jms.jar` which is exactly the same jar which is available using `mvn:javax.jms/javax.jms-api/2.0.1`

We *should not* rely on the embedded `jms.jar`, otherwise we'd get `ClassCastException` when working with this driver, because
{f7} has its own version of JMS API from `mvn:javax.jms/javax.jms-api/2.0.1`.

Unfortunately, `com.ibm.mq.osgi.allclient_9.1.0.6.jar` bundle contains this manifest header:
[listing,options="nowrap"]
----
Require-Bundle =
	com.ibm.mq.osgi.allclientprereqs;visibility:=reexport
----

Fuse 7.7 and later redefines `pax-jms-ibmmq` feature and adds single bundle `mvn:org.jboss.fuse.modules/fuse-pax-jms-ibmmq-compatibility/${version.org.jboss.fuse-karaf}` that satisfies the above requirement and prevents the situation where more bundles provide `javax.jms` package.

So the way to install IBM MQ drivers is:
[listing,options="nowrap"]
----
karaf@root()> install 'file:///data/downloads/ibm.com/IBM%20MQ/9.1.0.6-IBM-MQ-Install-Java-All/wmq/OSGi/com.ibm.mq.osgi.allclient_9.1.0.6.jar'
Bundle ID: 317
karaf@root()> feature:install pax-jms-ibmmq
karaf@root()> la -l | grep allclient
317 │ Resolved │  80 │ 9.1.0.6                   │ file:///data/downloads/ibm.com/IBM%20MQ/9.1.0.6-IBM-MQ-Install-Java-All/wmq/OSGi/com.ibm.mq.osgi.allclient_9.1.0.6.jar
karaf@root()> start 317
karaf@root()> feature:install pax-jms-config
karaf@root()> la -l
START LEVEL 100 , List Threshold: 0
 ID │ State    │ Lvl │ Version                  │ Location
────┼──────────┼─────┼──────────────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
...
266 │ Active   │  80 │ 1.0.7                    │ mvn:org.ops4j.pax.jms/pax-jms-api/1.0.7
267 │ Active   │  80 │ 1.0.7                    │ mvn:org.ops4j.pax.jms/pax-jms-config/1.0.7
319 │ Active   │  80 │ 1.0.7                    │ mvn:org.ops4j.pax.jms/pax-jms-ibmmq/1.0.7
...
karaf@root()> la -l | grep ibm
START LEVEL 100 , List Threshold: 0
 ID │ State    │ Lvl │ Version                  │ Location
────┼──────────┼─────┼──────────────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
...
317 │ Active   │  80 │ 9.1.0.6                   │ file:///data/downloads/ibm.com/IBM%20MQ/9.1.0.6-IBM-MQ-Install-Java-All/wmq/OSGi/com.ibm.mq.osgi.allclient_9.1.0.6.jar
318 │ Active   │  35 │ 7.8.0.fuse-780028         │ mvn:org.jboss.fuse.modules/fuse-pax-jms-ibmmq-compatibility/7.8.0.fuse-780028
----

IMPORTANT: When installing `com.ibm.mq.osgi.allclient_9.1.0.6.jar` bundle first, we can't start it, because it requires the _prerequisites_ bundle provided by `pax-jms-ibmmq` feature. Only after feature installation, we can start `com.ibm.mq.osgi.allclient_9.1.0.6.jar` bundle. It can't stay at `RESOLVED` state, because only after start it provides necessary services.

We can however prepare custom Karaf feature, where both `pax-jms-ibmmq` and the driver will be installed. Here's the example:
[source,option="nowrap",xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<features name="xa-connection-factories-clients" xmlns="http://karaf.apache.org/xmlns/features/v1.5.0">
    <feature name="ibmmq9-jms-client">
        <feature>pax-jms-ibmmq</feature>
        <bundle>file:///path/to/com.ibm.mq.osgi.allclient_9.1.0.6.jar</bundle>
    </feature>
</features>
----

`<bundle>` should point to custom location of the driver, which can't be distributed with {f7}.

And now:
[listing,options="nowrap"]
----
karaf@root()> bundle:services -p org.ops4j.pax.jms.pax-jms-ibmmq

OPS4J Pax JMS IBM MQ Support (319) provides:
--------------------------------------------
objectClass = [org.ops4j.pax.jms.service.ConnectionFactoryFactory]
service.bundleid = 319
service.id = 609
service.scope = singleton
type = ibmmq
----

. Create _factory configuration_:
+
[listing,options="nowrap"]
----
karaf@root()> config:edit --factory --alias ibmmq org.ops4j.connectionfactory
karaf@root()> config:property-set type ibmmq
karaf@root()> config:property-set osgi.jndi.service.name jms/mq9 # "name" property may be used too
karaf@root()> config:property-set connectionFactoryType ConnectionFactory # or XAConnectionFactory
karaf@root()> config:property-set jms.queueManager FUSEQM
karaf@root()> config:property-set jms.hostName localhost
karaf@root()> config:property-set jms.port 1414
karaf@root()> config:property-set jms.transportType 1 # com.ibm.msg.client.wmq.WMQConstants.WMQ_CM_CLIENT
karaf@root()> config:property-set jms.channel DEV.APP.SVRCONN
karaf@root()> config:property-set jms.CCSID 1208 # com.ibm.msg.client.jms.JmsConstants.CCSID_UTF8
karaf@root()> config:update

karaf@root()> config:list '(service.factoryPid=org.ops4j.connectionfactory)'
----------------------------------------------------------------
Pid:            org.ops4j.connectionfactory.e94ff3b4-fb45-4a20-b14b-6110b255d21e
FactoryPid:     org.ops4j.connectionfactory
BundleLocation: ?
Properties:
   connectionFactoryType = ConnectionFactory
   felix.fileinstall.filename = file:${karaf.etc}/org.ops4j.connectionfactory-ibmmq.cfg
   jms.CCSID = 1208
   jms.channel = DEV.APP.SVRCONN
   jms.hostName = localhost
   jms.port = 1414
   jms.queueManager = FUSEQM
   jms.transportType = 1
   osgi.jndi.service.name = jms/mq9
   service.factoryPid = org.ops4j.connectionfactory
   service.pid = org.ops4j.connectionfactory.e94ff3b4-fb45-4a20-b14b-6110b255d21e
   type = ibmmq
----

. Check if `pax-jms-config` processed the configuration into `javax.jms.ConnectionFactory` service:
+
[listing,options="nowrap"]
----
karaf@root()> service:list javax.jms.ConnectionFactory
[javax.jms.ConnectionFactory]
-----------------------------
 connectionFactoryType = ConnectionFactory
 felix.fileinstall.filename = file:${karaf.etc}/org.ops4j.connectionfactory-ibmmq.cfg
 jms.CCSID = 1208
 jms.channel = DEV.APP.SVRCONN
 jms.hostName = localhost
 jms.port = 1414
 jms.queueManager = FUSEQM
 jms.transportType = 1
 osgi.jndi.service.name = jms/mq9
 pax.jms.managed = true
 service.bundleid = 267
 service.factoryPid = org.ops4j.connectionfactory
 service.id = 610
 service.pid = org.ops4j.connectionfactory.e94ff3b4-fb45-4a20-b14b-6110b255d21e
 service.scope = singleton
 type = ibmmq
Provided by :
 OPS4J Pax JMS Config (267)
----

. Test the connection
+
[listing,options="nowrap"]
----
karaf@root()> feature:install -v jms
Adding features: jms/[4.2.9.fuse-780015,4.2.9.fuse-780015]
...
karaf@root()> jms:connectionfactories
JMS Connection Factory
──────────────────────
jms/mq9

karaf@root()> jms:info -u app -p fuse jms/mq9
Property │ Value
─────────┼────────────────────
product  │ IBM MQ JMS Provider
version  │ 8.0.0.0

karaf@root()> jms:send -u app -p fuse jms/mq9 DEV.QUEUE.1 "Hello IBM MQ 9 from PAX-JMS"

karaf@root()> jms:browse -u app -p fuse jms/mq9 DEV.QUEUE.1
Message ID                                          │ Content                     │ Charset │ Type │ Correlation ID │ Delivery Mode │ Destination          │ Expiration │ Priority │ Redelivered │ ReplyTo │ Timestamp
────────────────────────────────────────────────────┼─────────────────────────────┼─────────┼──────┼────────────────┼───────────────┼──────────────────────┼────────────┼──────────┼─────────────┼─────────┼──────────────────────────────
ID:414d512046555345514d20202020202049c88e5f035c3d25 │ Hello IBM MQ 9 from PAX-JMS │ UTF-8   │      │                │ Persistent    │ queue:///DEV.QUEUE.1 │ Never      │ 4        │ false       │         │ Tue Oct 20 14:27:39 CEST 2020
----

We can check if the message was sent also from IBM MQ Explorer or from [web console].

=== Summary of handled properties

Properties from configuration admin _factory PID_ are passed to relevant `org.ops4j.pax.jms.service.ConnectionFactoryFactory`
implementation.

.ActiveMQ - org.ops4j.pax.jms.activemq.ActiveMQConnectionFactoryFactory
* properties passed to `org.apache.activemq.ActiveMQConnectionFactory.buildFromMap()` method

.Artemis - org.ops4j.pax.jms.artemis.ArtemisConnectionFactoryFactory
* if `protocol=amqp`, properties are passed to `org.apache.qpid.jms.util.PropertyUtil.setProperties()` method to configure
`org.apache.qpid.jms.JmsConnectionFactory` instance
* otherwise, `org.apache.activemq.artemis.utils.uri.BeanSupport.setData()` is called for `org.apache.activemq.artemis.jms.client.ActiveMQConnectionFactory`
instance

.IBM MQ - org.ops4j.pax.jms.ibmmq.MQConnectionFactoryFactory
* bean properties of `com.ibm.mq.jms.MQConnectionFactory` or `com.ibm.mq.jms.MQXAConnectionFactory` are handled

== Using console commands

Apache Karaf provides `jms` feature that includes shell commands in the `jms:*` scope. We already tried some of them
to check manually configured connection factories, but there are also commands that hide the need to create
Configuration Admin configurations.

We could register broker-specific connection factory using (starting with fresh instance of {f7}):

.Install `jms` feature from Karaf and `pax-jms-artemis` from pax-jms
[listing,options="nowrap"]
----
karaf@root()> feature:install jms pax-jms-artemis

karaf@root()> jms:connectionfactories
JMS Connection Factory
──────────────────────
karaf@root()> service:list javax.jms.ConnectionFactory # should be empty

karaf@root()> service:list org.ops4j.pax.jms.service.ConnectionFactoryFactory
[org.ops4j.pax.jms.service.ConnectionFactoryFactory]
----------------------------------------------------
 service.bundleid = 268
 service.id = 298
 service.scope = singleton
 type = artemis
Provided by :
 OPS4J Pax JMS Artemis Support (268)
----

.Create and check Artemis connection factory
[listing,options="nowrap"]
----
karaf@root()> jms:create -t artemis -u fuse -p fuse --url tcp://localhost:61616 artemis

karaf@root()> jms:connectionfactories
JMS Connection Factory
──────────────────────
jms/artemis

karaf@root()> jms:info -u fuse -p fuse jms/artemis
Property │ Value
─────────┼────────────────────
product  │ ActiveMQ
version  │ 2.13.0.redhat-00006

karaf@root()> jms:send -u fuse -p fuse jms/artemis DEV.QUEUE.1 "Hello Artemis from PAX-JMS"

karaf@root()> jms:browse -u fuse -p fuse jms/artemis DEV.QUEUE.1
Message ID                              │ Content                    │ Charset │ Type │ Correlation ID │ Delivery Mode │ Destination                │ Expiration │ Priority │ Redelivered │ ReplyTo │ Timestamp
────────────────────────────────────────┼────────────────────────────┼─────────┼──────┼────────────────┼───────────────┼────────────────────────────┼────────────┼──────────┼─────────────┼─────────┼──────────────────────────────
ID:5ee7f6a9-939d-11ea-8c33-54e1ad3055fb │ Hello Artemis from PAX-JMS │ UTF-8   │      │                │ Persistent    │ ActiveMQQueue[DEV.QUEUE.1] │ Never      │ 4        │ false       │         │ Mon May 11 17:37:49 CEST 2020

karaf@root()> config:list '(service.factoryPid=org.ops4j.connectionfactory)'
----------------------------------------------------------------
Pid:            org.ops4j.connectionfactory.1eeb196b-b2b0-4889-95af-b38c95ddd8f8
FactoryPid:     org.ops4j.connectionfactory
BundleLocation: mvn:org.ops4j.pax.jms/pax-jms-config/1.0.7
Properties:
   name = artemis
   osgi.jndi.service.name = jms/artemis
   password = fuse
   service.factoryPid = org.ops4j.connectionfactory
   service.pid = org.ops4j.connectionfactory.1eeb196b-b2b0-4889-95af-b38c95ddd8f8
   type = artemis
   url = tcp://localhost:61616
   user = fuse
----

As we can see, `org.ops4j.connectionfactory` factory PID was created for us. However it's not automatically stored in
`${karaf.etc}`, which is possible with `config:update`. There's also no way to specify other properties (but we can
add them later).

== Using encrypted configuration values

Same as with `pax-jdbc-config`, we can use Jasypt to encrypt properties

If there's any `org.jasypt.encryption.StringEncryptor` service registered in OSGi with any `alias` service property,
we can refrence it in connection factory _factory PID_ and use encrypted passwords. Here's an example:
[listing,options="nowrap"]
----
felix.fileinstall.filename = */etc/org.ops4j.connectionfactory-artemis.cfg
name = artemis
type = artemis
decryptor = my-jasypt-decryptor
url = tcp://localhost:61616
user = fuse
password = ENC(<encrypted-password>)
----

The service filter used to find decryptor service is `(&(objectClass=org.jasypt.encryption.StringEncryptor)(alias=<alias>))`,
where `<alias>` is the value of `decryptor` property from connection factory configuration _factory PID_.

NOTE: An instruction about how to use Jasypt may be added here soon....

[[jms-connection-pools]]
== Using connection pools

As in <<jdbc-connection-pools>> chapter, it's time to present JMS connection/session pooling options.
There's less choice than with JDBC though.

IMPORTANT: In order to use XA recovery, `pax-jms-pool-transx` or `pax-jms-pool-narayana` should be used.

So far we've registered broker-specific connection *factory* (because _connection factory_ itself is a factory for connections,
`org.ops4j.pax.jms.service.ConnectionFactoryFactory` may be treated as _meta factory_) that should be able to produce
2 kinds of connection factories:

* `javax.jms.ConnectionFactory`
* `javax.jms.XAConnectionFactory`

`pax-jms-pool-*` bundles work smoothly with the above described `org.ops4j.pax.jms.service.ConnectionFactoryFactory`
services. These bundles provide implementations of `org.ops4j.pax.jms.service.PooledConnectionFactoryFactory` that
can be used to create pooled connection factory using set of properties and original `org.ops4j.pax.jms.service.ConnectionFactoryFactory`
(in a kind of _wrapper_ way).

[source, java, options="nowrap"]
----
public interface PooledConnectionFactoryFactory {

    ConnectionFactory create(ConnectionFactoryFactory cff, Map<String, Object> props);

}
----

What bundles register pooled connection factory factories (`o.o.p.j.p` == `org.ops4j.pax.jms.pool`)?

|===
|Bundle |PooledConnectionFactoryFactory |pool key

|`pax-jms-pool-pooledjms`
|`o.o.p.j.p.pooledjms.PooledJms(XA)PooledConnectionFactoryFactory`
|`pooledjms`

|`pax-jms-pool-narayana`
|`o.o.p.j.p.narayana.PooledJms(XA)PooledConnectionFactoryFactory`
|`narayana`

|`pax-jms-pool-transx`
|`o.o.p.j.p.transx.Transx(XA)PooledConnectionFactoryFactory`
|`transx`
|===

NOTE: `pax-jms-pool-narayana` factory is called `PooledJms(XA)PooledConnectionFactoryFactory` because it is based
on pooled-jms library - just adding integration with Narayana Transaction Manager in terms of XA Recovery.

The above bundles only install connection factory factories. Not the connection factory themselves. So again we need something
that'll actually call `javax.jms.ConnectionFactory org.ops4j.pax.jms.service.PooledConnectionFactoryFactory.create()` method.

=== pax-jms-pool-pooledjms

We'll describe the integration with this pool for explanatory purposes.

<<pax-jms-config,pax-jms-config>> bundle in addition to tracking:

* `org.ops4j.pax.jms.service.ConnectionFactoryFactory` services
* `org.ops4j.connectionfactory` _factory PIDs_

also tracks instances of `org.ops4j.pax.jms.service.PooledConnectionFactoryFactory` registered by one of `pax-jms-pool-*` bundles.

If _factory configuration_ contains `pool` property, the ultimate connection factory registered by `pax-jms-config` bundle
will be the broker-specific connection factory, but wrapped inside one of (if `pool=pooledjms`):

* `org.messaginghub.pooled.jms.JmsPoolConnectionFactory` (`xa=false`)
* `org.messaginghub.pooled.jms.JmsPoolXAConnectionFactory` (`xa=true`)

Besides `pool` property (and boolean `xa` property, which selects one of non-xa/xa connection factories),
`org.ops4j.connectionfactory` _factory PID_ may contain properties prefixed with `pool.`.

For pooled-jms these prefixed properties are used (after removing the prefix) to configure instance of:

* `org.messaginghub.pooled.jms.JmsPoolConnectionFactory`, or
* `org.messaginghub.pooled.jms.JmsPoolXAConnectionFactory`

Here's quite realistic configuration of pooled-jms pool (`org.ops4j.connectionfactory-artemis` _factory PID_)
using convenient syntax with `jms.`-prefixed properties:

[listing, options="nowrap"]
----
# configuration for pax-jms-config to choose and configure specific org.ops4j.pax.jms.service.ConnectionFactoryFactory
name = artemisCF
connectionFactoryType = ConnectionFactory
jms.url = tcp://localhost:61616
jms.user = fuse
jms.password = fuse
# org.apache.activemq.artemis.jms.client.ActiveMQConnectionFactory specific coniguration
jms.callTimeout = 12000
# ...

# hints for pax-jms-config to use selected org.ops4j.pax.jms.service.PooledConnectionFactoryFactory
pool = pooledjms
xa = false

# pooled-jms specific configuration of org.messaginghub.pooled.jms.JmsPoolConnectionFactory
pool.connectionIdleTimeout = 10
pool.maxConnections = 100
pool.blockIfSessionPoolIsFull = true
# ...
----

In the above configuration, `pool` and `xa` keys are _hints_ (service filter properties) to choose one of registered
`org.ops4j.pax.jms.service.PooledConnectionFactoryFactory` services. In case of pooled-jms it's:
[listing, options="nowrap"]
----
karaf@root()> feature:install pax-jms-pool-pooledjms

karaf@root()> bundle:services -p org.ops4j.pax.jms.pax-jms-pool-pooledjms

OPS4J Pax JMS MessagingHub JMS Pool implementation (245) provides:
------------------------------------------------------------------
objectClass = [org.ops4j.pax.jms.service.PooledConnectionFactoryFactory]
pool = pooledjms
service.bundleid = 245
service.id = 254
service.scope = singleton
xa = false
- - - -
objectClass = [org.ops4j.pax.jms.service.PooledConnectionFactoryFactory]
pool = pooledjms
service.bundleid = 245
service.id = 255
service.scope = singleton
xa = true
----

==== Example

For completeness, here's full example with connection pool configuration:

. Install required features:
+
[listing,options="nowrap"]
----
karaf@root()> feature:install -v pax-jms-pool-pooledjms pax-jms-artemis
Adding features: pax-jms-pool-pooledjms/[1.0.7,1.0.7],pax-jms-artemis/[1.0.7,1.0.7]
...
----

. Install `jms` feature
+
[listing,options="nowrap"]
----
karaf@root()> feature:install jms

karaf@root()> service:list org.ops4j.pax.jms.service.ConnectionFactoryFactory
[org.ops4j.pax.jms.service.ConnectionFactoryFactory]
----------------------------------------------------
 service.bundleid = 267
 service.id = 258
 service.scope = singleton
 type = artemis
Provided by :
 OPS4J Pax JMS Artemis Support (267)

karaf@root()> service:list org.ops4j.pax.jms.service.PooledConnectionFactoryFactory
[org.ops4j.pax.jms.service.PooledConnectionFactoryFactory]
----------------------------------------------------------
 pool = pooledjms
 service.bundleid = 245
 service.id = 254
 service.scope = singleton
 xa = false
Provided by :
 OPS4J Pax JMS MessagingHub JMS Pool implementation (245)

[org.ops4j.pax.jms.service.PooledConnectionFactoryFactory]
----------------------------------------------------------
 pool = pooledjms
 service.bundleid = 245
 service.id = 320
 service.scope = singleton
 xa = true
Provided by :
 OPS4J Pax JMS MessagingHub JMS Pool implementation (245)

[org.ops4j.pax.jms.service.PooledConnectionFactoryFactory]
----------------------------------------------------------
 pool = transx
 service.bundleid = 271
 service.id = 311
 service.scope = singleton
 xa = false
Provided by :
 OPS4J Pax JMS Pax TRANSX JMS pool (271)

[org.ops4j.pax.jms.service.PooledConnectionFactoryFactory]
----------------------------------------------------------
 pool = transx
 service.bundleid = 271
 service.id = 325
 service.scope = singleton
 xa = true
Provided by :
 OPS4J Pax JMS Pax TRANSX JMS pool (271)
----

. Create _factory configuration_:
+
[listing,options="nowrap"]
----
karaf@root()> config:edit --factory --alias artemis org.ops4j.connectionfactory
karaf@root()> config:property-set connectionFactoryType ConnectionFactory
karaf@root()> config:property-set name artemisCF
karaf@root()> config:property-set type artemis
karaf@root()> config:property-set protocol amqp # so we switch to org.apache.qpid.jms.JmsConnectionFactory
karaf@root()> config:property-set jms.url amqp://localhost:61616
karaf@root()> config:property-set jms.username fuse
karaf@root()> config:property-set jms.password fuse
karaf@root()> config:property-set pool pooledjms
karaf@root()> config:property-set xa false
karaf@root()> config:property-set pool.connectionIdleTimeout 10
karaf@root()> config:property-set pool.maxConnections 123
karaf@root()> config:property-set pool.blockIfSessionPoolIsFull true
karaf@root()> config:update
----

. Check if `pax-jms-config` processed the configuration into `javax.jms.ConnectionFactory` service:
+
[listing,options="nowrap"]
----
karaf@root()> service:list javax.jms.ConnectionFactory
[javax.jms.ConnectionFactory]
-----------------------------
 connectionFactoryType = ConnectionFactory
 felix.fileinstall.filename = file:${karaf.etc}/org.ops4j.connectionfactory-artemis.cfg
 jms.password = fuse
 jms.url = amqp://localhost:61616
 jms.username = fuse
 name = artemisCF
 osgi.jndi.service.name = artemisCF
 pax.jms.managed = true
 pool.blockIfSessionPoolIsFull = true
 pool.connectionIdleTimeout = 10
 pool.maxConnections = 123
 protocol = amqp
 service.bundleid = 270
 service.factoryPid = org.ops4j.connectionfactory
 service.id = 327
 service.pid = org.ops4j.connectionfactory.a09092c9-3afc-4813-a22f-5d746e911dbb
 service.scope = singleton
 type = artemis
Provided by :
 OPS4J Pax JMS Config (270)
----

. Use the connection factory
+
[listing,options="nowrap"]
----
karaf@root()> jms:connectionfactories
JMS Connection Factory
──────────────────────
artemisCF

karaf@root()> jms:info -u fuse -p fuse artemisCF
Property │ Value
─────────┼────────────────────
product  │ QpidJMS
version  │ 0.51.0.redhat-00002

karaf@root()> jms:send -u fuse -p fuse artemisCF DEV.QUEUE.1 "Hello Artemis from PAX-JMS"

karaf@root()> jms:browse -u fuse -p fuse artemisCF DEV.QUEUE.1
Message ID                                      │ Content                    │ Charset │ Type │ Correlation ID │ Delivery Mode │ Destination │ Expiration │ Priority │ Redelivered │ ReplyTo │ Timestamp
────────────────────────────────────────────────┼────────────────────────────┼─────────┼──────┼────────────────┼───────────────┼─────────────┼────────────┼──────────┼─────────────┼─────────┼──────────────────────────────
ID:adc80d08-ab3c-4b2a-86f0-1d199805da9e:2:1:1-1 │ Hello Artemis from PAX-JMS │ UTF-8   │      │                │ Persistent    │ DEV.QUEUE.1 │ Never      │ 4        │ false       │         │ Mon May 11 17:40:37 CEST 2020
----

=== pax-jms-pool-narayana

For clarification, `pax-jms-pool-narayna` does almost everything as `pax-jms-pool-pooledjms` - installs pooled-jms-specific
`org.ops4j.pax.jms.service.PooledConnectionFactoryFactory` - both for XA and non-XA scenarios. The *only* difference is
that in XA scenario we have additional integration point:

* `org.jboss.tm.XAResourceRecovery` OSGi service is registered to be picked up by `com.arjuna.ats.arjuna.recovery.RecoveryManager`

=== pax-jms-pool-transx

The implementation of `org.ops4j.pax.jms.service.PooledConnectionFactoryFactory` services provided by this bundle is
based on `pax-transx-jms` bundle, which creates `javax.jms.ConnectionFactory` pools using
`org.ops4j.pax.transx.jms.ManagedConnectionFactoryBuilder` facility.
This is JCA (Java™ Connector Architecture) based solution and will be described <<pax-transx,later>>.

== Deploying connection factories as artifacts

As with JDBC, I've left the real-world recommendation to the end of this chapter.

In _deployment method_, `javax.jms.ConnectionFactory` services are registered directly by application code - usually inside
Blueprint container. Blueprint XML may be part of ordinary OSGi bundle, installable using `mvn:` URI and stored in
Maven repository (local or remote). It's much easier to version-control such bundles comparing to Configuration Admin
configurations.

`pax-jms-config` version 1.0.0 adds a _deployment method_ for connection factory configuration. Application developer
registers `javax.jms.(XA)ConnectionFactory` service (usually using Bluerpint XML) and specifies service properties. Then
`pax-jms-config` detects such registered broker-specific connection factory and (using service properties) wraps the
service inside generic, non broker-specific connection pool.

For completeness, I'll present *three* _deployment methods_ using Blueprint XML.

=== Manual deployment of connection factories

In this method, we don't need `pax-jms-config` at all. Application code is responsible for registration of both
broker-specific and generic connection pool.

[source,xml,options="nowrap"]
----
<!--
    Broker-specific, non-pooling, non-enlisting javax.jms.XAConnectionFactory
-->
<bean id="artemis" class="org.apache.activemq.artemis.jms.client.ActiveMQXAConnectionFactory">
    <argument value="tcp://localhost:61616" />
    <property name="callTimeout" value="2000" />
    <property name="initialConnectAttempts" value="3" />
</bean>

<!--
    Fuse exports this service from fuse-pax-transx-tm-narayana bundle
-->
<reference id="tm" interface="javax.transaction.TransactionManager" />

<!--
    Non broker-specific, generic, pooling, enlisting javax.jms.ConnectionFactory
-->
<bean id="pool" class="org.messaginghub.pooled.jms.JmsPoolXAConnectionFactory">
    <property name="connectionFactory" ref="artemis" />
    <property name="transactionManager" ref="tm" />
    <property name="maxConnections" value="10" />
    <property name="connectionIdleTimeout" value="10000" />
</bean>

<!--
    Expose connection factory to use by application code (like Camel, Spring, ...)
-->
<service interface="javax.jms.ConnectionFactory" ref="pool">
    <service-properties>
        <!-- Giving connection factory a name using one of these properties makes identification easier in jms:connectionfactories: -->
        <entry key="osgi.jndi.service.name" value="jms/artemis" />
        <!--<entry key="name" value="jms/artemis" />-->
        <!-- Without any of the above, name will fallback to "service.id" -->
    </service-properties>
</service>
----

Here are the shell commands that show how it should be used:

[listing,options="nowrap"]
----
karaf@root()> feature:install artemis-core-client artemis-jms-client
karaf@root()> install -s mvn:org.apache.commons/commons-pool2/2.8.0
Bundle ID: 78
karaf@root()> install -s mvn:org.messaginghub/pooled-jms/1.1.1.redhat-00002
Bundle ID: 262
karaf@root()> install -s blueprint:file://$PQ_HOME/message-brokers/blueprints/artemis-manual.xml
Bundle ID: 263

karaf@root()> bundle:services -p 263

Bundle 263 provides:
--------------------
objectClass = [javax.jms.ConnectionFactory]
osgi.jndi.service.name = jms/artemis
osgi.service.blueprint.compname = pool
service.bundleid = 263
service.id = 265
service.scope = bundle
- - - -
objectClass = [org.osgi.service.blueprint.container.BlueprintContainer]
osgi.blueprint.container.symbolicname = artemis-manual.xml
osgi.blueprint.container.version = 0.0.0
service.bundleid = 263
service.id = 266
service.scope = singleton

karaf@root()> feature:install jms

karaf@root()> jms:connectionfactories
JMS Connection Factory
──────────────────────
jms/artemis

karaf@root()> jms:info -u fuse -p fuse jms/artemis
Property │ Value
─────────┼────────────────────
product  │ ActiveMQ
version  │ 2.13.0.redhat-00006
----

As shown in the above listing, blueprint bundle exports `javax.jms.ConnectionFactory` service which
is generic, non broker-specific connection pool.
The broker-specific `javax.jms.XAConnectionFactory` is *not* registered as OSGi service, because Blueprint
XML doesn't have explicit `<service ref="artemis">` declaration.

=== Factory deployment of connection factories

In this method, we use `pax-jms-config` in a _canonical_ way. That's a bit different method than the one
recommended in Fuse 6.x, where we need to specify pooling configuration as service properties.

Here's the Blueprint XML example:

[source,xml,options="nowrap"]
----
<!--
    A broker-specific org.ops4j.pax.jms.service.ConnectionFactoryFactory that can create (XA)ConnectionFactory
    using properties. It's registered by pax-jms-* bundles
-->
<reference id="connectionFactoryFactory"
        interface="org.ops4j.pax.jms.service.ConnectionFactoryFactory"
        filter="(type=artemis)" />

<!--
    Non broker-specific org.ops4j.pax.jms.service.PooledConnectionFactoryFactory that can create
    pooled connection factories with the help of org.ops4j.pax.jms.service.ConnectionFactoryFactory

    For example, pax-jms-pool-pooledjms bundle registers org.ops4j.pax.jms.service.PooledConnectionFactoryFactory
    with these properties:
     - pool = pooledjms
     - xa = true|false (both are registered)
-->
<reference id="pooledConnectionFactoryFactory"
        interface="org.ops4j.pax.jms.service.PooledConnectionFactoryFactory"
        filter="(&amp;(pool=pooledjms)(xa=true))" />

<!--
    When using XA connection factories, javax.transaction.TransactionManager service is not needed here - it's used
    internally by xa-aware pooledConnectionFactoryFactory
-->
<!--<reference id="tm" interface="javax.transaction.TransactionManager" />-->

<!--
    Finally we can use both factories to expose pooled, xa-aware connection factory
-->
<bean id="pool" factory-ref="pooledConnectionFactoryFactory" factory-method="create">
    <argument ref="connectionFactoryFactory" />
    <argument>
        <props>
            <!--
                Properties needed by artemis-specific org.ops4j.pax.jms.service.ConnectionFactoryFactory
            -->
            <prop key="jms.url" value="tcp://localhost:61616" />
            <prop key="jms.callTimeout" value="2000" />
            <prop key="jms.initialConnectAttempts" value="3" />
            <!-- Properties needed by pooled-jms-specific org.ops4j.pax.jms.service.PooledConnectionFactoryFactory -->
            <prop key="pool.maxConnections" value="10" />
            <prop key="pool.connectionIidleTimeout" value="10000" />
        </props>
    </argument>
</bean>

<!--
    Expose connection factory to use by application code (like Camel, Spring, ...)
-->
<service interface="javax.jms.ConnectionFactory" ref="pool">
    <service-properties>
        <!-- Giving connection factory a name using one of these properties makes identification easier in jms:connectionfactories: -->
        <entry key="osgi.jndi.service.name" value="jms/artemis" />
        <!--<entry key="name" value="jms/artemis" />-->
        <!-- Without any of the above, name will fallback to "service.id" -->
    </service-properties>
</service>
----

In the above example, we use _factory_ beans that create connection factories using connection factory factories (...).
We don't need explicit reference to `javax.transaction.TransactionManager` service, as this is tracked
internally by XA-aware `PooledConnectionFactoryFactory`.

Here's how it looks like in Fuse/Karaf shell:

[listing,options="nowrap"]
----
karaf@root()> feature:install jms pax-jms-artemis pax-jms-pool-pooledjms

karaf@root()> install -s blueprint:file://$PQ_HOME/message-brokers/blueprints/artemis-pax-jms-factory-pooledjms.xml
Bundle ID: 274
karaf@root()> bundle:services -p 274

Bundle 274 provides:
--------------------
objectClass = [javax.jms.ConnectionFactory]
osgi.jndi.service.name = jms/artemis
osgi.service.blueprint.compname = pool
service.bundleid = 274
service.id = 323
service.scope = bundle
- - - -
objectClass = [org.osgi.service.blueprint.container.BlueprintContainer]
osgi.blueprint.container.symbolicname = artemis-pax-jms-factory-pooledjms.xml
osgi.blueprint.container.version = 0.0.0
service.bundleid = 274
service.id = 324
service.scope = singleton

karaf@root()> jms:connectionfactories
JMS Connection Factory
──────────────────────
jms/artemis

karaf@root()> jms:info -u fuse -p fuse jms/artemis
Property │ Value
─────────┼────────────────────
product  │ ActiveMQ
version  │ 2.13.0.redhat-00006
----

As shown in the above listing, blueprint bundle exports `javax.jms.ConnectionFactory` service which
is generic, non broker-specific connection pool.
The broker-specific `javax.jms.XAConnectionFactory` is *not* registered as OSGi service, because Blueprint
XML doesn't have explicit `<service ref="artemis">` declaration.

=== Mixed deployment of connection factories

`pax-jms-config` 1.0.0 adds another way of _wrapping_ broker-specific connection factories within pooling
connection factories using service properties. This method matches the way it used to work in Fuse 6.x.

Here's the Blueprint XML example:

[source,xml,options="nowrap"]
----
    <!--
        Broker-specific, non-pooling, non-enlisting javax.jms.XAConnectionFactory
    -->
    <bean id="artemis" class="org.apache.activemq.artemis.jms.client.ActiveMQXAConnectionFactory">
        <argument value="tcp://localhost:61616" />
        <property name="callTimeout" value="2000" />
        <property name="initialConnectAttempts" value="3" />
    </bean>

    <!--
        Expose broker-specific connection factory with service properties
        No need to expose pooling, enlisting, non broker-specific javax.jms.XAConnectionFactory - it'll be registered
        automatically by pax-jms-config with the same properties as this <service>, but with higher service.ranking
    -->
    <service id="pool" ref="artemis" interface="javax.jms.XAConnectionFactory">
        <service-properties>
            <!-- "pool" key is needed for pax-jms-config to wrap broker-specific connection factory inside connection pool -->
            <entry key="pool" value="pooledjms" />
            <!-- <service>/@id attribute doesn't propagate, but name of the connection factory is required using one of: -->
            <entry key="osgi.jndi.service.name" value="jms/artemis" />
            <!-- or: -->
            <!--<entry key="name" value="jms/artemis" />-->
            <!-- Other properties, that normally by e.g., pax-jms-pool-pooledjms -->
            <entry key="pool.maxConnections" value="10" />
            <entry key="pool.connectionIdleTimeout" value="10000" />
        </service-properties>
    </service>
----

In the above example, we manually register only broker-specific connection factory. `pool=pooledjms` service property
is a hint for connection factory tracker managed by `pax-jms-config` bundle. Connection Factory services with this service property
will be wrapped within pooling connection factory (in this example - `pax-jms-pool-pooledjms`).

Here's how it looks like in Fuse/Karaf shell:

[listing,options="nowrap"]
----
karaf@root()> feature:install jms pax-jms-config pax-jms-artemis pax-jms-pool-pooledjms

karaf@root()> install -s blueprint:file://$PQ_HOME/message-brokers/blueprints/artemis-pax-jms-discovery.xml
Bundle ID: 274

karaf@root()> bundle:services -p 274

Bundle 274 provides:
--------------------
objectClass = [javax.jms.XAConnectionFactory]
osgi.jndi.service.name = jms/artemis
osgi.service.blueprint.compname = artemis
pool = pooledjms
pool.connectionIdleTimeout = 10000
pool.maxConnections = 10
service.bundleid = 274
service.id = 323
service.scope = bundle
- - - -
objectClass = [org.osgi.service.blueprint.container.BlueprintContainer]
osgi.blueprint.container.symbolicname = artemis-pax-jms-discovery.xml
osgi.blueprint.container.version = 0.0.0
service.bundleid = 274
service.id = 325
service.scope = singleton

karaf@root()> service:list javax.jms.XAConnectionFactory
[javax.jms.XAConnectionFactory]
-------------------------------
 osgi.jndi.service.name = jms/artemis
 osgi.service.blueprint.compname = artemis
 pool = pooledjms
 pool.connectionIdleTimeout = 10000
 pool.maxConnections = 10
 service.bundleid = 274
 service.id = 323
 service.scope = bundle
Provided by :
 Bundle 274
Used by:
 OPS4J Pax JMS Config (269)

karaf@root()> service:list javax.jms.ConnectionFactory
[javax.jms.ConnectionFactory]
-----------------------------
 osgi.jndi.service.name = jms/artemis
 osgi.service.blueprint.compname = artemis
 pax.jms.managed = true
 pax.jms.service.id.ref = 323
 pool.connectionIdleTimeout = 10000
 pool.maxConnections = 10
 service.bundleid = 269
 service.id = 324
 service.ranking = 1000
 service.scope = singleton
Provided by :
 OPS4J Pax JMS Config (269)

karaf@root()> jms:connectionfactories
JMS Connection Factory
──────────────────────
jms/artemis

karaf@root()> jms:info -u fuse -p fuse jms/artemis
Property │ Value
─────────┼────────────────────
product  │ ActiveMQ
version  │ 2.13.0.redhat-00006
----

This time, `jms:connectionfactories` shows only one service, but that's becuase this command removes duplicate names.

`javax.jms.XAConnectionFactory` is registered from the Blueprint bundle and have `pool = pooledjms` property declared.

`javax.jms.ConnectionFactory` is registered from `pax-jms-config` bundle and:

* doesn't have `pool = pooledjms` property (it was removed when registering wrapper connection factory)
* has `service.ranking = 1000` property, so it's always preferred version when e.g., looking for connection factory by name
* has `pax.jms.managed = true` property, so it's not tried to be wrapped again
* has `pax.jms.service.id.ref = 323` property, so we know what's the original connection factory service that's wrapped
inside connection pool

== Summary

I'm happy to reach the point, where both JDBC and JMS are handled consistently.
