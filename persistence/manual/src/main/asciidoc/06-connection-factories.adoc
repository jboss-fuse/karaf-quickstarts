= ConnectionFactory configuration

Without going into that many details as in <<datasource-configuration,DataSource configuration chapter>>, we'll
present how JMS connection factories may be used in OSGi.

Fundamentally, it's done using:

[source, java, options="nowrap"]
----
org.osgi.framework.BundleContext.registerService(javax.jms.ConnectionFactory.class,
                                                 connectionFactoryObject,
                                                 properties);
org.osgi.framework.BundleContext.registerService(javax.jms.XAConnectionFactory.class,
                                                 xaConnectionFactoryObject,
                                                 properties);
----

There are two different methods to register such services:

* publishing connection factories using `jms:create` Karaf console command. We can call it _configuration method_.

* publishing connection factories using methods like Blueprint, OSGi Declarative Services (SCR) or just
`BundleContext.registerService()` API call. This method requires dedicated OSGi bundle that contains the code and/or
metadata. We can call it _deployment method_.

== OSGi JMS Service

OSGi way of handling JDBC data sources is related to two interfaces:

* _standard_ `org.osgi.service.jdbc.DataSourceFactory`
* _proprietary_ `org.ops4j.pax.jdbc.pool.common.PooledDataSourceFactory`

For JMS we have these analogies:

* _proprietary_ `org.ops4j.pax.jms.service.ConnectionFactoryFactory` with the same purpose as _standard_ OSGi JDBC `org.osgi.service.jdbc.DataSourceFactory`
* _proprietary_ `org.ops4j.pax.jms.service.PooledConnectionFactoryFactory` with the same purpose as _proprietary_ pax-jdbc `org.ops4j.pax.jdbc.pool.common.PooledDataSourceFactory`

.Dedicated, broker-specific org.ops4j.pax.jms.service.ConnectionFactoryFactory implementations

There are bundles like:

* `mvn:org.ops4j.pax.jms/pax-jms-activemq/1.0.0`
* `mvn:org.ops4j.pax.jms/pax-jms-artemis/1.0.0`
* `mvn:org.ops4j.pax.jms/pax-jms-ibmmq/1.0.0`

that register broker-specific `org.ops4j.pax.jms.service.ConnectionFactoryFactory` services that can return
JMS _factories_ (`javax.jms.ConnectionFactory` and `javax.jms.XAConnectionFactory`). For example:

[literal, options="nowrap"]
----
karaf@root()> feature:install pax-jms-activemq

karaf@root()> bundle:services -p org.ops4j.pax.jms.pax-jms-config

OPS4J Pax JMS Config (265) provides:
------------------------------------
objectClass = [org.osgi.service.cm.ManagedServiceFactory]
service.bundleid = 265
service.id = 251
service.pid = org.ops4j.connectionfactory
service.scope = singleton

karaf@root()> bundle:services -p org.ops4j.pax.jms.pax-jms-activemq

OPS4J Pax JMS ActiveMQ Support (263) provides:
----------------------------------------------
objectClass = [org.ops4j.pax.jms.service.ConnectionFactoryFactory]
service.bundleid = 263
service.id = 258
service.scope = singleton
type = activemq
----

[[pax-jms-config]]
== PAX-JMS configuration service

`mvn:org.ops4j.pax.jms/pax-jms-config/1.0.0` bundle provides a Managed Service Factory
that does two things:

* tracks `org.ops4j.pax.jms.service.ConnectionFactoryFactory` OSGi services in order to invoke its methods:
+
[source,java,options="nowrap"]
....
public ConnectionFactory createConnectionFactory(Map<String, Object> properties);

public XAConnectionFactory createXAConnectionFactory(Map<String, Object> properties);
....

* tracks `org.ops4j.connectionfactory` _factory PIDs_ in order to collect properties required by the above methods.
If we create a _factory configuration_ using any method available for Configuration Admin service, for example by
creating `${karaf.etc}/org.ops4j.connectionfactory-activemq.cfg` file, we can perform the final step to expose actual
broker-specific connection factory.

[[canonical-pax-jms-config-example]]
Here's the detailed, _canonical_ step-by-step guide.

. Install ActiveMQ driver (simplest way is to use `pax-jms-activemq` feature, but it uses `activemq-osgi` bundle
which is rather _catch all_ solution and may lead to installation of too many dependencies, like Jetty) and
`pax-jms-config` features:
+
[listing,options="nowrap"]
----
karaf@root()> feature:install pax-jms-activemq

karaf@root()> bundle:services -p org.ops4j.pax.jms.pax-jms-config

OPS4J Pax JMS Config (265) provides:
------------------------------------
objectClass = [org.osgi.service.cm.ManagedServiceFactory]
service.bundleid = 265
service.id = 251
service.pid = org.ops4j.connectionfactory
service.scope = singleton

karaf@root()> bundle:services -p org.ops4j.pax.jms.pax-jms-activemq

OPS4J Pax JMS ActiveMQ Support (263) provides:
----------------------------------------------
objectClass = [org.ops4j.pax.jms.service.ConnectionFactoryFactory]
service.bundleid = 263
service.id = 258
service.scope = singleton
type = activemq
----

. Create _factory configuration_:
+
[listing,options="nowrap"]
----
karaf@root()> config:edit --factory --alias activemq org.ops4j.connectionfactory
karaf@root()> config:property-set type activemq
karaf@root()> config:property-set osgi.jndi.service.name activemqCF # "name" property may be used too
karaf@root()> config:property-set connectionFactoryType ConnectionFactory # or XAConnectionFactory
karaf@root()> config:property-set jms.url tcp://localhost:61616
karaf@root()> config:property-set jms.user fuse
karaf@root()> config:property-set jms.password fuse
karaf@root()> config:property-set jms.prefetchPolicy.queuePrefetch 1234
karaf@root()> config:update

karaf@root()> config:list '(service.factoryPid=org.ops4j.connectionfactory)'
----------------------------------------------------------------
Pid:            org.ops4j.connectionfactory.b852f0aa-cc81-48aa-9fef-feabf476d2de
FactoryPid:     org.ops4j.connectionfactory
BundleLocation: ?
Properties:
   connectionFactoryType = ConnectionFactory
   felix.fileinstall.filename = file:${karaf.etc}/org.ops4j.connectionfactory-activemq.cfg
   jms.password = fuse
   jms.prefetchPolicy.queuePrefetch = 1234
   jms.url = tcp://localhost:61616
   jms.user = fuse
   osgi.jndi.service.name = activemqCF
   service.factoryPid = org.ops4j.connectionfactory
   service.pid = org.ops4j.connectionfactory.b852f0aa-cc81-48aa-9fef-feabf476d2de
   type = activemq
----

. Check if `pax-jms-config` processed the configuration into `javax.jms.ConnectionFactory` service:
+
[listing,options="nowrap"]
----
karaf@root()> service:list javax.jms.ConnectionFactory
[javax.jms.ConnectionFactory]
-----------------------------
 connectionFactoryType = ConnectionFactory
 felix.fileinstall.filename = file:${karaf.etc}/org.ops4j.connectionfactory-activemq.cfg
 jms.password = fuse
 jms.prefetchPolicy.queuePrefetch = 1234
 jms.url = tcp://localhost:61616
 jms.user = fuse
 osgi.jndi.service.name = activemqCF
 pax.jms.managed = true
 service.bundleid = 265
 service.factoryPid = org.ops4j.connectionfactory
 service.id = 261
 service.pid = org.ops4j.connectionfactory.b852f0aa-cc81-48aa-9fef-feabf476d2de
 service.scope = singleton
 type = activemq
Provided by :
 OPS4J Pax JMS Config (265)
----

Now we have actual broker-specific (no pooling yet) connection factory. We can already inject it where needed. For example we can
use Karaf commands from `jms` feature:
[listing,options="nowrap"]
----
karaf@root()> feature:install -v jms
Adding features: jms/[4.2.0.fuse-000199,4.2.0.fuse-000199]
...
karaf@root()> jms:connectionfactories
JMS Connection Factory
──────────────────────
activemqCF

karaf@root()> jms:info activemqCF
Error executing command: JMS 2.0 is not supported by ActiveMQ

karaf@root()> jms:send activemqCF DEV.QUEUE.1 "Hello ActiveMQ"
Error executing command: JMS 2.0 is not supported by ActiveMQ
----

As we can see in logs:
[listing, options="nowrap"]
----
2018-04-18 19:47:31,977 ERROR {Karaf local console user karaf} [org.apache.karaf.shell.support.ShellUtil.logException()] (ShellUtil.java:149) : Exception caught while executing command
java.lang.UnsupportedOperationException: JMS 2.0 is not supported by ActiveMQ
	at org.ops4j.pax.jms.activemq.ActiveMQConnectionFactoryFactory$1.createContext(ActiveMQConnectionFactoryFactory.java:77) ~[?:?]
	at org.apache.karaf.jms.internal.JmsServiceImpl.createContext(JmsServiceImpl.java:155) ~[?:?]
	at org.apache.karaf.jms.internal.JmsServiceImpl.createContext(JmsServiceImpl.java:148) ~[?:?]
	at org.apache.karaf.jms.internal.JmsServiceImpl.send(JmsServiceImpl.java:228) ~[?:?]
	at org.apache.karaf.jms.command.SendCommand.execute(SendCommand.java:40) ~[?:?]
...
----

Karaf JMS commands use JMS 2.0 _simplified_ API - `javax.jms.JMSContext`. Let's try Artemis then:

[listing,options="nowrap"]
----
karaf@root()> feature:install pax-jms-artemis

karaf@root()> bundle:services -p org.ops4j.pax.jms.pax-jms-config

OPS4J Pax JMS Config (258) provides:
------------------------------------
objectClass = [org.osgi.service.cm.ManagedServiceFactory]
service.bundleid = 258
service.id = 258
service.pid = org.ops4j.connectionfactory
service.scope = singleton

karaf@root()> bundle:services -p org.ops4j.pax.jms.pax-jms-config

OPS4J Pax JMS Config (258) provides:
------------------------------------
objectClass = [org.osgi.service.cm.ManagedServiceFactory]
service.bundleid = 258
service.id = 258
service.pid = org.ops4j.connectionfactory
service.scope = singleton
karaf@root()> bundle:services -p org.ops4j.pax.jms.pax-jms-artemis

OPS4J Pax JMS Artemis Support (257) provides:
---------------------------------------------
objectClass = [org.ops4j.pax.jms.service.ConnectionFactoryFactory]
service.bundleid = 257
service.id = 257
service.scope = singleton
type = artemis
----

. Create _factory configuration_:
+
[listing,options="nowrap"]
----
karaf@root()> config:edit --factory --alias artemis org.ops4j.connectionfactory
karaf@root()> config:property-set type artemis
karaf@root()> config:property-set osgi.jndi.service.name jms/artemis # "name" property may be used too
karaf@root()> config:property-set connectionFactoryType ConnectionFactory # or XAConnectionFactory
karaf@root()> config:property-set jms.url tcp://localhost:61616
karaf@root()> config:property-set jms.user fuse
karaf@root()> config:property-set jms.password fuse
karaf@root()> config:property-set jms.consumerMaxRate 1234
karaf@root()> config:update

karaf@root()> config:list '(service.factoryPid=org.ops4j.connectionfactory)'
----------------------------------------------------------------
Pid:            org.ops4j.connectionfactory.dd0958c9-3599-430b-a223-57415efcb28d
FactoryPid:     org.ops4j.connectionfactory
BundleLocation: ?
Properties:
   connectionFactoryType = ConnectionFactory
   felix.fileinstall.filename = file:${karaf.etc}/org.ops4j.connectionfactory-artemis.cfg
   jms.consumerMaxRate = 1234
   jms.password = fuse
   jms.url = tcp://localhost:61616
   jms.user = fuse
   osgi.jndi.service.name = jms/artemis
   service.factoryPid = org.ops4j.connectionfactory
   service.pid = org.ops4j.connectionfactory.dd0958c9-3599-430b-a223-57415efcb28d
   type = artemis
----
+
NOTE: If we specify additional for Artemis configuration - `protocol=amqp`, QPID JMS library would be used instead of Artemis JMS client.
`amqp://` protocol has to be used then for `jms.url` property.

. Check if `pax-jms-config` processed the configuration into `javax.jms.ConnectionFactory` service:
+
[listing,options="nowrap"]
----
karaf@root()> service:list javax.jms.ConnectionFactory
[javax.jms.ConnectionFactory]
-----------------------------
 connectionFactoryType = ConnectionFactory
 felix.fileinstall.filename = file:${karaf.etc}/org.ops4j.connectionfactory-artemis.cfg
 jms.consumerMaxRate = 1234
 jms.password = fuse
 jms.url = tcp://localhost:61616
 jms.user = fuse
 osgi.jndi.service.name = jms/artemis
 pax.jms.managed = true
 service.bundleid = 258
 service.factoryPid = org.ops4j.connectionfactory
 service.id = 261
 service.pid = org.ops4j.connectionfactory.dd0958c9-3599-430b-a223-57415efcb28d
 service.scope = singleton
 type = artemis
Provided by :
 OPS4J Pax JMS Config (258)
----

Now we have actual broker-specific (no pooling yet) connection factory. We can already inject it where needed. For example we can
use Karaf commands from `jms` feature:
[listing,options="nowrap"]
----
    karaf@root()> feature:install -v jms
Adding features: jms/[4.2.0.fuse-000199,4.2.0.fuse-000199]
...
karaf@root()> jms:connectionfactories
JMS Connection Factory
──────────────────────
jms/artemis

karaf@root()> jms:info -u fuse -p fuse jms/artemis
Property │ Value
─────────┼──────────────────────────
product  │ ActiveMQ
version  │ 2.4.0.amq-710008-redhat-1

karaf@root()> jms:send -u fuse -p fuse jms/artemis DEV.QUEUE.1 "Hello Artemis from PAX-JMS"

karaf@root()> jms:browse -u fuse -p fuse jms/artemis DEV.QUEUE.1
Message ID                              │ Content                    │ Charset │ Type │ Correlation ID │ Delivery Mode │ Destination                │ Expiration │ Priority │ Redelivered │ ReplyTo │ Timestamp
────────────────────────────────────────┼────────────────────────────┼─────────┼──────┼────────────────┼───────────────┼────────────────────────────┼────────────┼──────────┼─────────────┼─────────┼──────────────────────────────
ID:23d545dd-4334-11e8-9085-761e8f1ecfb9 │ Hello Artemis from PAX-JMS │ UTF-8   │      │                │ Persistent    │ ActiveMQQueue[DEV.QUEUE.1] │ Never      │ 4        │ false       │         │ Wed Apr 18 20:13:05 CEST 2018
----

Let's switch the protocol:
[listing,options="nowrap"]
----
karaf@root()> config:list '(service.factoryPid=org.ops4j.connectionfactory)'
----------------------------------------------------------------
Pid:            org.ops4j.connectionfactory.312eb09a-d686-4229-b7e1-2ea38a77bb0f
FactoryPid:     org.ops4j.connectionfactory
BundleLocation: ?
Properties:
   connectionFactoryType = ConnectionFactory
   felix.fileinstall.filename = file:${karaf.etc}/org.ops4j.connectionfactory-artemis.cfg
   jms.consumerMaxRate = 1234
   jms.password = fuse
   jms.url = tcp://localhost:61616
   jms.user = fuse
   osgi.jndi.service.name = jms/artemis
   service.factoryPid = org.ops4j.connectionfactory
   service.pid = org.ops4j.connectionfactory.312eb09a-d686-4229-b7e1-2ea38a77bb0f
   type = artemis

karaf@root()> config:edit org.ops4j.connectionfactory.312eb09a-d686-4229-b7e1-2ea38a77bb0f
karaf@root()> config:property-set protocol amqp
karaf@root()> config:property-delete user
karaf@root()> config:property-set username fuse # mind the difference between artemis-jms-client and qpid-jms-client
karaf@root()> config:property-set jms.url amqp://localhost:61616
karaf@root()> config:update

karaf@root()> jms:info -u fuse -p fuse jms/artemis
Property │ Value
─────────┼────────
product  │ QpidJMS
version  │ 0.30.0
----

[[ibmmq-osgi-package]]
For completeness, let's see how we can connect to IBM MQ 9. Even if `pax-jms-ibmmq` installs relevant `pax-jms`
bundles, IBM MQ driver is not installed due to licensing reasons.

As mentioned in <<ibm-mq,chapter about IBM MQ>>, we can download drivers from https://developer.ibm.com/messaging/mq-downloads/[IBM MQ page].
`OSGi` directory of `9.0.5.0-IBM-MQ-Install-Java-All.jar` package contains only two bundles:

* `com.ibm.mq.osgi.allclient_9.0.5.0.jar` - actual driver
* `com.ibm.mq.osgi.allclientprereqs_9.0.5.0.jar` - preprequisites

While the prerequisites JAR contain required `fscontext.jar` and `providerutil.jar` libraries, it also contains:

* `bcprov-jdk15on-157.jar` and `bcpkix-jdk15on-157.jar`, while {f7} ships those (in newer version) in `$FUSE_HOME/lib/ext`
* `jms.jar` which is exactly the same jar which is available using `mvn:javax.jms/javax.jms-api/2.0`

We *can't* rely on the embedded `jms.jar`, otherwise we'd get `ClassCastException` when working with this driver, because
{f7} has its own version of JMS API from `mvn:javax.jms/javax.jms-api/2.0.1`.

Unfortunately, `com.ibm.mq.osgi.allclient_9.0.5.0.jar` bundle contains this manifest header:
[listing,options="nowrap"]
----
Require-Bundle =
	com.ibm.mq.osgi.allclientprereqs;visibility:=reexport
----

So without a _hack_ with installing an empty bundle with `com.ibm.mq.osgi.allclientprereqs` symbolic name, we actually
can't use `com.ibm.mq.osgi.allclient_9.0.5.0.jar` bundle.

So the method I used is:

* unpack `fscontext.jar` and `providerutil.jar` from `com.ibm.mq.osgi.allclientprereqs_9.0.5.0.jar`, or copy them
from `9.0.5.0-IBM-MQ-Install-Java-All/JavaSE`
* copy these 2 libraries to `$FUSE_HOME/lib/ext` - `$FUSE_HOME/etc/config.properties` already has correct
configuration of the packages from these libraries in `org.osgi.framework.system.packages.extra` property
* install 6 bundles from `MQSeriesJava-9.0.5-0.x86_64.cpio` package:
+
[listing,options="nowrap"]
----
karaf@root()> install 'file:///data/downloads/ibm.com/IBM%20MQ/MQSeriesJava-9.0.5-0.x86_64/java/lib/OSGi/com.ibm.msg.client.osgi.commonservices.j2se_9.0.5.0.jar'
Bundle ID: 234
karaf@root()> install 'file:///data/downloads/ibm.com/IBM%20MQ/MQSeriesJava-9.0.5-0.x86_64/java/lib/OSGi/com.ibm.msg.client.osgi.jms_9.0.5.0.jar'
Bundle ID: 235
karaf@root()> install 'file:///data/downloads/ibm.com/IBM%20MQ/MQSeriesJava-9.0.5-0.x86_64/java/lib/OSGi/com.ibm.msg.client.osgi.nls_9.0.5.0.jar'
Bundle ID: 236
karaf@root()> install 'file:///data/downloads/ibm.com/IBM%20MQ/MQSeriesJava-9.0.5-0.x86_64/java/lib/OSGi/com.ibm.msg.client.osgi.wmq.nls_9.0.5.0.jar'
Bundle ID: 237
karaf@root()> install 'file:///data/downloads/ibm.com/IBM%20MQ/MQSeriesJava-9.0.5-0.x86_64/java/lib/OSGi/com.ibm.msg.client.osgi.wmq.prereq_9.0.5.0.jar'
Bundle ID: 238
karaf@root()> install 'file:///data/downloads/ibm.com/IBM%20MQ/MQSeriesJava-9.0.5-0.x86_64/java/lib/OSGi/com.ibm.msg.client.osgi.wmq_9.0.5.0.jar'
Bundle ID: 239

karaf@root()> resolve

karaf@root()> # start non-fragment bundles:

karaf@root()> la -l|grep ibm.msg
234 │ Active   │  80 │ 9.0.5.0               │ file://.../com.ibm.msg.client.osgi.commonservices.j2se_9.0.5.0.jar
235 │ Active   │  80 │ 9.0.5.0               │ file://.../com.ibm.msg.client.osgi.jms_9.0.5.0.jar
236 │ Active   │  80 │ 9.0.5.0               │ file://.../com.ibm.msg.client.osgi.nls_9.0.5.0.jar
237 │ Resolved │  80 │ 9.0.5.0               │ file://.../com.ibm.msg.client.osgi.wmq.nls_9.0.5.0.jar
238 │ Active   │  80 │ 9.0.5.0               │ file://.../com.ibm.msg.client.osgi.wmq.prereq_9.0.5.0.jar
239 │ Active   │  80 │ 9.0.5.0               │ file://.../com.ibm.msg.client.osgi.wmq_9.0.5.0.jar
----
+
These bundles could also be put into custom feature and installed using `feature:install` command.

And now:
[listing,options="nowrap"]
----
karaf@root()> feature:install pax-jms-ibmmq

karaf@root()> bundle:services -p org.ops4j.pax.jms.pax-jms-ibmmq

OPS4J Pax JMS IBM MQ Support (242) provides:
--------------------------------------------
objectClass = [org.ops4j.pax.jms.service.ConnectionFactoryFactory]
service.bundleid = 242
service.id = 247
service.scope = singleton
type = ibmmq
----

. Create _factory configuration_:
+
[listing,options="nowrap"]
----
karaf@root()> config:edit --factory --alias ibmmq org.ops4j.connectionfactory
karaf@root()> config:property-set type ibmmq
karaf@root()> config:property-set osgi.jndi.service.name jms/mq9 # "name" property may be used too
karaf@root()> config:property-set connectionFactoryType ConnectionFactory # or XAConnectionFactory
karaf@root()> config:property-set jms.queueManager FUSEQM
karaf@root()> config:property-set jms.hostName localhost
karaf@root()> config:property-set jms.port 1414
karaf@root()> config:property-set jms.transportType 1 # com.ibm.msg.client.wmq.WMQConstants.WMQ_CM_CLIENT
karaf@root()> config:property-set jms.channel DEV.APP.SVRCONN
karaf@root()> config:property-set jms.CCSID 1208 # com.ibm.msg.client.jms.JmsConstants.CCSID_UTF8
karaf@root()> config:update

karaf@root()> config:list '(service.factoryPid=org.ops4j.connectionfactory)'
----------------------------------------------------------------
Pid:            org.ops4j.connectionfactory.0412012a-9149-403b-8ea2-9dea0497e300
FactoryPid:     org.ops4j.connectionfactory
BundleLocation: ?
Properties:
   connectionFactoryType = ConnectionFactory
   felix.fileinstall.filename = file:${karaf.etc}/org.ops4j.connectionfactory-ibmmq.cfg
   jms.CCSID = 1208
   jms.channel = DEV.APP.SVRCONN
   jms.hostName = localhost
   jms.port = 1414
   jms.queueManager = FUSEQM
   jms.transportType = 1
   osgi.jndi.service.name = jms/mq9
   service.factoryPid = org.ops4j.connectionfactory
   service.pid = org.ops4j.connectionfactory.0412012a-9149-403b-8ea2-9dea0497e300
   type = ibmmq
----

. Check if `pax-jms-config` processed the configuration into `javax.jms.ConnectionFactory` service:
+
[listing,options="nowrap"]
----
karaf@root()> service:list javax.jms.ConnectionFactory
[javax.jms.ConnectionFactory]
-----------------------------
 connectionFactoryType = ConnectionFactory
 felix.fileinstall.filename = file:${karaf.etc}/org.ops4j.connectionfactory-ibmmq.cfg
 jms.CCSID = 1208
 jms.channel = DEV.APP.SVRCONN
 jms.hostName = localhost
 jms.port = 1414
 jms.queueManager = FUSEQM
 jms.transportType = 1
 osgi.jndi.service.name = jms/mq9
 pax.jms.managed = true
 service.bundleid = 241
 service.factoryPid = org.ops4j.connectionfactory
 service.id = 251
 service.pid = org.ops4j.connectionfactory.0412012a-9149-403b-8ea2-9dea0497e300
 service.scope = singleton
 type = ibmmq
Provided by :
 OPS4J Pax JMS Config (241)
----

. Test the connection
+
[listing,options="nowrap"]
----
karaf@root()> feature:install -v jms
Adding features: jms/[4.2.0.fuse-000199,4.2.0.fuse-000199]
...
karaf@root()> jms:connectionfactories
JMS Connection Factory
──────────────────────
jms/mq9

karaf@root()> jms:info -u app -p fuse jms/mq9
Property │ Value
─────────┼────────────────────
product  │ IBM MQ JMS Provider
version  │ 8.0.0.0

karaf@root()> jms:send -u app -p fuse jms/mq9 DEV.QUEUE.1 "Hello IBM MQ 9 from PAX-JMS"

karaf@root()> jms:browse -u app -p fuse jms/mq9 DEV.QUEUE.1
Message ID                                          │ Content                     │ Charset │ Type │ Correlation ID │ Delivery Mode │ Destination          │ Expiration │ Priority │ Redelivered │ ReplyTo │ Timestamp
────────────────────────────────────────────────────┼─────────────────────────────┼─────────┼──────┼────────────────┼───────────────┼──────────────────────┼────────────┼──────────┼─────────────┼─────────┼──────────────────────────────
ID:414d512046555345514d2020202020200d38d85a0202e023 │ Hello IBM MQ 9 from PAX-JMS │ UTF-8   │      │                │ Persistent    │ queue:///DEV.QUEUE.1 │ Never      │ 4        │ false       │         │ Thu Apr 19 13:19:42 CEST 2018
----

We can check if the message was sent also from IBM MQ Explorer or from [web console].

=== Summary of handled properties

Properties from configuration admin _factory PID_ are passed to relevant `org.ops4j.pax.jms.service.ConnectionFactoryFactory`
implementation.

.ActiveMQ - org.ops4j.pax.jms.activemq.ActiveMQConnectionFactoryFactory
* properties passed to `org.apache.activemq.ActiveMQConnectionFactory.buildFromMap()` method

.Artemis - org.ops4j.pax.jms.artemis.ArtemisConnectionFactoryFactory
* if `protocol=amqp`, properties are passed to `org.apache.qpid.jms.util.PropertyUtil.setProperties()` method to configure
`org.apache.qpid.jms.JmsConnectionFactory` instance
* otherwise, `org.apache.activemq.artemis.utils.uri.BeanSupport.setData()` is called for `org.apache.activemq.artemis.jms.client.ActiveMQConnectionFactory`
instance

.IBM MQ - org.ops4j.pax.jms.ibmmq.MQConnectionFactoryFactory
* bean properties of `com.ibm.mq.jms.MQConnectionFactory` or `com.ibm.mq.jms.MQXAConnectionFactory` are handled

== Using console commands

Apache Karaf provides `jms` feature that includes shell commands in the `jms:*` scope. We already tried some of them
to check manually configured connection factories, but there are also commands that hide the need to create
Configuration Admin configurations.

We could register broker-specific connection factory using (starting with fresh instance of {f7}):

.Install `jms` feature from Karaf and `pax-jms-artemis` from pax-jms
[listing,options="nowrap"]
----
karaf@root()> feature:install jms pax-jms-artemis

karaf@root()> jms:connectionfactories
JMS Connection Factory
──────────────────────
karaf@root()> service:list javax.jms.ConnectionFactory # should be empty

karaf@root()> service:list org.ops4j.pax.jms.service.ConnectionFactoryFactory
[org.ops4j.pax.jms.service.ConnectionFactoryFactory]
----------------------------------------------------
 service.bundleid = 257
 service.id = 258
 service.scope = singleton
 type = artemis
Provided by :
 OPS4J Pax JMS Artemis Support (257)
----

.Create and check Artemis connection factory
[listing,options="nowrap"]
----
karaf@root()> jms:create -t artemis -u fuse -p fuse --url tcp://localhost:61616 artemis

karaf@root()> jms:connectionfactories
JMS Connection Factory
──────────────────────
jms/artemis

karaf@root()> jms:info -u fuse -p fuse jms/artemis
Property │ Value
─────────┼──────────────────────────
product  │ ActiveMQ
version  │ 2.4.0.amq-711002-redhat-1

karaf@root()> jms:send -u fuse -p fuse jms/artemis DEV.QUEUE.1 "Hello Artemis from PAX-JMS"

karaf@root()> jms:browse -u fuse -p fuse jms/artemis DEV.QUEUE.1
Message ID                              │ Content                    │ Charset │ Type │ Correlation ID │ Delivery Mode │ Destination                                                         │ Expiration │ Priority │ Redelivered │ ReplyTo │ Timestamp
────────────────────────────────────────┼────────────────────────────┼─────────┼──────┼────────────────┼───────────────┼─────────────────────────────────────────────────────────────────────┼────────────┼──────────┼─────────────┼─────────┼──────────────────────────────
ID:1e2b106a-43f4-11e8-ae9f-02235a7aacad │ Hello Artemis from PAX-JMS │ UTF-8   │      │                │ Persistent    │ ActiveMQQueue[DEV.QUEUE.1]                                          │ Never      │ 4        │ false       │         │ Thu Apr 19 19:07:19 CEST 2018

karaf@root()> config:list '(service.factoryPid=org.ops4j.connectionfactory)'
----------------------------------------------------------------
Pid:            org.ops4j.connectionfactory.241101b6-acce-4652-8f66-07975fe9c93c
FactoryPid:     org.ops4j.connectionfactory
BundleLocation: mvn:org.ops4j.pax.jms/pax-jms-config/1.0.0-SNAPSHOT
Properties:
   name = artemis
   osgi.jndi.service.name = jms/artemis
   password = fuse
   service.factoryPid = org.ops4j.connectionfactory
   service.pid = org.ops4j.connectionfactory.241101b6-acce-4652-8f66-07975fe9c93c
   type = artemis
   url = tcp://localhost:61616
   user = fuse
----

As we can see, `org.ops4j.connectionfactory` factory PID was created for us. However it's not automatically stored in
`${karaf.etc}`, which is possible with `config:update`. There's also no way to specify other properties (but we can
add them later).

== Using encrypted configuration values

Same as with `pax-jdbc-config`, we can use Jasypt to encrypt properties

If there's any `org.jasypt.encryption.StringEncryptor` service registered in OSGi with any `alias` service property,
we can refrence it in connection factory _factory PID_ and use encrypted passwords. Here's an example:
[listing,options="nowrap"]
----
felix.fileinstall.filename = */etc/org.ops4j.connectionfactory-artemis.cfg
name = artemis
type = artemis
decryptor = my-jasypt-decryptor
url = tcp://localhost:61616
user = fuse
password = ENC(<encrypted-password>)
----

The service filter used to find decryptor service is `(&(objectClass=org.jasypt.encryption.StringEncryptor)(alias=<alias>))`,
where `<alias>` is the value of `decryptor` property from connection factory configuration _factory PID_.

NOTE: An instruction about how to use Jasypt may be added here soon....

[[jms-connection-pools]]
== Using connection pools

As in <<jdbc-connection-pools>> chapter, it's time to present JMS connection/session pooling options.
There's less choice than with JDBC though.

IMPORTANT: In order to use XA recovery, `pax-jms-pool-transx` or `pax-jms-pool-narayana` should be used.

So far we've registered broker-specific connection *factory* (because _connection factory_ itself is a factory for connections,
`org.ops4j.pax.jms.service.ConnectionFactoryFactory` may be treated as _meta factory_) that should be able to produce
2 kinds of connection factories:

* `javax.jms.ConnectionFactory`
* `javax.jms.XAConnectionFactory`

`pax-jms-pool-*` bundles work smoothly with the above described `org.ops4j.pax.jms.service.ConnectionFactoryFactory`
services. These bundles provide implementations of `org.ops4j.pax.jms.service.PooledConnectionFactoryFactory` that
can be used to create pooled connection factory using set of properties and original `org.ops4j.pax.jms.service.ConnectionFactoryFactory`
(in a kind of _wrapper_ way).

[source, java, options="nowrap"]
----
public interface PooledConnectionFactoryFactory {

    ConnectionFactory create(ConnectionFactoryFactory cff, Map<String, Object> props);

}
----

What bundles register pooled connection factory factories (`o.o.p.j.p` == `org.ops4j.pax.jms.pool`)?

|===
|Bundle |PooledConnectionFactoryFactory |pool key

|`pax-jms-pool-pooledjms`
|`o.o.p.j.p.pooledjms.PooledJms(XA)PooledConnectionFactoryFactory`
|`pooledjms`

|`pax-jms-pool-narayana`
|`o.o.p.j.p.narayana.PooledJms(XA)PooledConnectionFactoryFactory`
|`narayana`

|`pax-jms-pool-transx`
|`o.o.p.j.p.transx.Transx(XA)PooledConnectionFactoryFactory`
|`transx`
|===

NOTE: `pax-jms-pool-narayana` factory is called `PooledJms(XA)PooledConnectionFactoryFactory` because it is based
on pooled-jms library - just adding integration with Narayana Transaction Manager in terms of XA Recovery.

The above bundles only install connection factory factories. Not the connection factory themselves. So again we need something
that'll actually call `javax.jms.ConnectionFactory org.ops4j.pax.jms.service.PooledConnectionFactoryFactory.create()` method.

=== pax-jms-pool-pooledjms

We'll describe the integration with this pool for explanatory purposes.

<<pax-jms-config,pax-jms-config>> bundle in addition to tracking:

* `org.ops4j.pax.jms.service.ConnectionFactoryFactory` services
* `org.ops4j.connectionfactory` _factory PIDs_

also tracks instances of `org.ops4j.pax.jms.service.PooledConnectionFactoryFactory` registered by one of `pax-jms-pool-*` bundles.

If _factory configuration_ contains `pool` property, the ultimate connection factory registered by `pax-jms-config` bundle
will be the broker-specific connection factory, but wrapped inside one of (if `pool=pooledjms`):

* `org.messaginghub.pooled.jms.JmsPoolConnectionFactory` (`xa=false`)
* `org.messaginghub.pooled.jms.JmsPoolXAConnectionFactory` (`xa=true`)

Besides `pool` property (and boolean `xa` property, which selects one of non-xa/xa connection factories),
`org.ops4j.connectionfactory` _factory PID_ may contain properties prefixed with `pool.`.

For pooled-jms these prefixed properties are used (after removing the prefix) to configure instance of:

* `org.messaginghub.pooled.jms.JmsPoolConnectionFactory`, or
* `org.messaginghub.pooled.jms.JmsPoolXAConnectionFactory`

Here's quite realistic configuration of pooled-jms pool (`org.ops4j.connectionfactory-artemis` _factory PID_)
using convenient syntax with `jms.`-prefixed properties:

[listing, options="nowrap"]
----
# configuration for pax-jms-config to choose and configure specific org.ops4j.pax.jms.service.ConnectionFactoryFactory
name = artemisCF
connectionFactoryType = ConnectionFactory
jms.url = tcp://localhost:61616
jms.user = fuse
jms.password = fuse
# org.apache.activemq.artemis.jms.client.ActiveMQConnectionFactory specific coniguration
jms.callTimeout = 12000
# ...

# hints for pax-jms-config to use selected org.ops4j.pax.jms.service.PooledConnectionFactoryFactory
pool = pooledjms
xa = false

# pooled-jms specific configuration of org.messaginghub.pooled.jms.JmsPoolConnectionFactory
pool.idleTimeout = 10
pool.maxConnections = 100
pool.blockIfSessionPoolIsFull = true
# ...
----

In the above configuration, `pool` and `xa` keys are _hints_ (service filter properties) to choose one of registered
`org.ops4j.pax.jms.service.PooledConnectionFactoryFactory` services. In case of pooled-jms it's:
[listing, options="nowrap"]
----
karaf@root()> feature:install pax-jms-pool-pooledjms

karaf@root()> bundle:services -p org.ops4j.pax.jms.pax-jms-pool-pooledjms

OPS4J Pax JMS MessagingHub JMS Pool implementation (237) provides:
------------------------------------------------------------------
objectClass = [org.ops4j.pax.jms.service.PooledConnectionFactoryFactory]
pool = pooledjms
service.bundleid = 237
service.id = 328
service.scope = singleton
xa = false
- - - -
objectClass = [org.ops4j.pax.jms.service.PooledConnectionFactoryFactory]
pool = pooledjms
service.bundleid = 237
service.id = 335
service.scope = singleton
xa = true
----

==== Example

For completeness, here's full example with connection pool configuration:

. Install required features:
+
[listing,options="nowrap"]
----
karaf@root()> feature:install -v pax-jms-pool-pooledjms pax-jms-artemis
Adding features: pax-jms-pool-pooledjms/[1.0.0,1.0.0]
...
----

. Install `jms` feature
+
[listing,options="nowrap"]
----
karaf@root()> feature:install jms

karaf@root()> service:list org.ops4j.pax.jms.service.ConnectionFactoryFactory
[org.ops4j.pax.jms.service.ConnectionFactoryFactory]
----------------------------------------------------
 service.bundleid = 262
 service.id = 358
 service.scope = singleton
 type = artemis
Provided by :
 OPS4J Pax JMS Artemis Support (262)

karaf@root()> service:list org.ops4j.pax.jms.service.PooledConnectionFactoryFactory
[org.ops4j.pax.jms.service.PooledConnectionFactoryFactory]
----------------------------------------------------------
 pool = pooledjms
 service.bundleid = 237
 service.id = 343
 service.scope = singleton
 xa = false
Provided by :
 OPS4J Pax JMS MessagingHub JMS Pool implementation (237)

[org.ops4j.pax.jms.service.PooledConnectionFactoryFactory]
----------------------------------------------------------
 pool = pooledjms
 service.bundleid = 237
 service.id = 344
 service.scope = singleton
 xa = true
Provided by :
 OPS4J Pax JMS MessagingHub JMS Pool implementation (237)
----

. Create _factory configuration_:
+
[listing,options="nowrap"]
----
karaf@root()> config:edit --factory --alias artemis org.ops4j.connectionfactory
karaf@root()> config:property-set connectionFactoryType ConnectionFactory
karaf@root()> config:property-set name artemisCF
karaf@root()> config:property-set type artemis
karaf@root()> config:property-set protocol amqp # so we switch to org.apache.qpid.jms.JmsConnectionFactory
karaf@root()> config:property-set jms.url amqp://localhost:61616
karaf@root()> config:property-set jms.username fuse
karaf@root()> config:property-set jms.password fuse
karaf@root()> config:property-set pool pooledjms
karaf@root()> config:property-set xa false
karaf@root()> config:property-set pool.idleTimeout 10
karaf@root()> config:property-set pool.maxConnections 123
karaf@root()> config:property-set pool.blockIfSessionPoolIsFull true
karaf@root()> config:update
----

. Check if `pax-jms-config` processed the configuration into `javax.jms.ConnectionFactory` service:
+
[listing,options="nowrap"]
----
karaf@root()> service:list javax.jms.ConnectionFactory
[javax.jms.ConnectionFactory]
-----------------------------
 connectionFactoryType = ConnectionFactory
 felix.fileinstall.filename = file:${karaf.etc}/org.ops4j.connectionfactory-artemis.cfg
 jms.url = amqp://localhost:61616
 jms.username = fuse
 jms.password = fuse
 name = artemisCF
 osgi.jndi.service.name = artemisCF
 pax.jms.managed = true
 pool.blockIfSessionPoolIsFull = true
 pool.idleTimeout = 10
 pool.maxConnections = 123
 protocol = amqp
 service.bundleid = 236
 service.factoryPid = org.ops4j.connectionfactory
 service.id = 362
 service.pid = org.ops4j.connectionfactory.c3ce6896-f427-4f43-b3dc-ed005d44ab3c
 service.scope = singleton
 type = artemis
Provided by :
 OPS4J Pax JMS Config (236)
----

. Use the connection factory
+
[listing,options="nowrap"]
----
karaf@root()> jms:connectionfactories
JMS Connection Factory
──────────────────────
artemisCF

karaf@root()> jms:info -u fuse -p fuse artemisCF
Property │ Value
─────────┼────────
product  │ QpidJMS
version  │ 0.30.0

karaf@root()> jms:send -u fuse -p fuse artemisCF DEV.QUEUE.1 "Hello Artemis from PAX-JMS"

karaf@root()> jms:browse -u fuse -p fuse artemisCF DEV.QUEUE.1
Message ID                                      │ Content                    │ Charset │ Type │ Correlation ID │ Delivery Mode │ Destination │ Expiration │ Priority │ Redelivered │ ReplyTo │ Timestamp
────────────────────────────────────────────────┼────────────────────────────┼─────────┼──────┼────────────────┼───────────────┼─────────────┼────────────┼──────────┼─────────────┼─────────┼──────────────────────────────
ID:22aae938-8df7-42c2-af45-f39d9a1b6c64:2:1:1-1 │ Hello Artemis from PAX-JMS │ UTF-8   │      │                │ Persistent    │ DEV.QUEUE.1 │ Never      │ 4        │ false       │         │ Thu Apr 19 19:51:07 CEST 2018
----

=== pax-jms-pool-narayana

For clarification, `pax-jms-pool-narayna` does almost everything as `pax-jms-pool-pooledjms` - installs pooled-jms-specific
`org.ops4j.pax.jms.service.PooledConnectionFactoryFactory` - both for XA and non-XA scenarios. The *only* difference is
that in XA scenario we have additional integration point:

* `org.jboss.tm.XAResourceRecovery` OSGi service is registered to be picked up by `com.arjuna.ats.arjuna.recovery.RecoveryManager`

=== pax-jms-pool-transx

The implementation of `org.ops4j.pax.jms.service.PooledConnectionFactoryFactory` services provided by this bundle is
based on `pax-transx-jms` bundle, which creates `javax.jms.ConnectionFactory` pools using
`org.ops4j.pax.transx.jms.ManagedConnectionFactoryBuilder` facility.
This is JCA (Java™ Connector Architecture) based solution and will be described <<pax-transx,later>>.

== Deploying connection factories as artifacts

As with JDBC, I've left the real-world recommendation to the end of this chapter.

In _deployment method_, `javax.jms.ConnectionFactory` services are registered directly by application code - usually inside
Blueprint container. Blueprint XML may be part of ordinary OSGi bundle, installable using `mvn:` URI and stored in
Maven repository (local or remote). It's much easier to version-control such bundles comparing to Configuration Admin
configurations.

`pax-jms-config` version 1.0.0 adds a _deployment method_ for connection factory configuration. Application developer
registers `javax.jms.(XA)ConnectionFactory` service (usually using Bluerpint XML) and specifies service properties. Then
`pax-jms-config` detects such registered broker-specific connection factory and (using service properties) wraps the
service inside generic, non broker-specific connection pool.

For completeness, I'll present *three* _deployment methods_ using Blueprint XML.

=== Manual deployment of connection factories

In this method, we don't need `pax-jms-config` at all. Application code is responsible for registration of both
broker-specific and generic connection pool.

[source,xml,options="nowrap"]
----
<!--
    Broker-specific, non-pooling, non-enlisting javax.jms.XAConnectionFactory
-->
<bean id="artemis" class="org.apache.activemq.artemis.jms.client.ActiveMQXAConnectionFactory">
    <argument value="tcp://localhost:61616" />
    <property name="callTimeout" value="2000" />
    <property name="initialConnectAttempts" value="3" />
</bean>

<!--
    Fuse exports this service from fuse-pax-transx-tm-narayana bundle
-->
<reference id="tm" interface="javax.transaction.TransactionManager" />

<!--
    Non broker-specific, generic, pooling, enlisting javax.jms.ConnectionFactory
-->
<bean id="pool" class="org.messaginghub.pooled.jms.JmsPoolXAConnectionFactory">
    <property name="connectionFactory" ref="artemis" />
    <property name="transactionManager" ref="tm" />
    <property name="maxConnections" value="10" />
    <property name="idleTimeout" value="10000" />
</bean>

<!--
    Expose connection factory to use by application code (like Camel, Spring, ...)
-->
<service interface="javax.jms.ConnectionFactory" ref="pool">
    <service-properties>
        <!-- Giving connection factory a name using one of these properties makes identification easier in jms:connectionfactories: -->
        <entry key="osgi.jndi.service.name" value="jms/artemis" />
        <!--<entry key="name" value="jms/artemis" />-->
        <!-- Without any of the above, name will fallback to "service.id" -->
    </service-properties>
</service>
----

Here are the shell commands that show how it should be used:

[listing,options="nowrap"]
----
karaf@root()> feature:install artemis-core-client artemis-jms-client
karaf@root()> install -s mvn:org.apache.commons/commons-pool2/2.5.0
Bundle ID: 81
karaf@root()> install -s mvn:org.messaginghub/pooled-jms/0.3.0
Bundle ID: 253
karaf@root()> install -s blueprint:file://$PQ_HOME/message-brokers/blueprints/artemis-manual.xml
Bundle ID: 264

karaf@root()> bundle:services -p 264

Bundle 264 provides:
--------------------
objectClass = [javax.jms.ConnectionFactory]
osgi.jndi.service.name = jms/artemis
osgi.service.blueprint.compname = pool
service.bundleid = 264
service.id = 267
service.scope = bundle
- - - -
objectClass = [org.osgi.service.blueprint.container.BlueprintContainer]
osgi.blueprint.container.symbolicname = artemis-manual.xml
osgi.blueprint.container.version = 0.0.0
service.bundleid = 264
service.id = 268
service.scope = singleton

karaf@root()> feature:install jms

karaf@root()> jms:connectionfactories
JMS Connection Factory
──────────────────────
jms/artemis

karaf@root()> jms:info -u fuse -p fuse jms/artemis
Property │ Value
─────────┼──────────────────────────
product  │ ActiveMQ
version  │ 2.4.0.amq-711002-redhat-1
----

As shown in the above listing, blueprint bundle exports `javax.jms.ConnectionFactory` service which
is generic, non broker-specific connection pool.
The broker-specific `javax.jms.XAConnectionFactory` is *not* registered as OSGi service, because Blueprint
XML doesn't have explicit `<service ref="artemis">` declaration.

=== Factory deployment of connection factories

In this method, we use `pax-jms-config` in a _canonical_ way. That's a bit different method than the one
recommended in Fuse 6.x, where we need to specify pooling configuration as service properties.

Here's the Blueprint XML example:

[source,xml,options="nowrap"]
----
<!--
    A broker-specific org.ops4j.pax.jms.service.ConnectionFactoryFactory that can create (XA)ConnectionFactory
    using properties. It's registered by pax-jms-* bundles
-->
<reference id="connectionFactoryFactory"
        interface="org.ops4j.pax.jms.service.ConnectionFactoryFactory"
        filter="(type=artemis)" />

<!--
    Non broker-specific org.ops4j.pax.jms.service.PooledConnectionFactoryFactory that can create
    pooled connection factories with the help of org.ops4j.pax.jms.service.ConnectionFactoryFactory

    For example, pax-jms-pool-pooledjms bundle registers org.ops4j.pax.jms.service.PooledConnectionFactoryFactory
    with these properties:
     - pool = pooledjms
     - xa = true|false (both are registered)
-->
<reference id="pooledConnectionFactoryFactory"
        interface="org.ops4j.pax.jms.service.PooledConnectionFactoryFactory"
        filter="(&amp;(pool=pooledjms)(xa=true))" />

<!--
    When using XA connection factories, javax.transaction.TransactionManager service is not needed here - it's used
    internally by xa-aware pooledConnectionFactoryFactory
-->
<!--<reference id="tm" interface="javax.transaction.TransactionManager" />-->

<!--
    Finally we can use both factories to expose pooled, xa-aware connection factory
-->
<bean id="pool" factory-ref="pooledConnectionFactoryFactory" factory-method="create">
    <argument ref="connectionFactoryFactory" />
    <argument>
        <props>
            <!--
                Properties needed by artemis-specific org.ops4j.pax.jms.service.ConnectionFactoryFactory
            -->
            <prop key="jms.url" value="tcp://localhost:61616" />
            <prop key="jms.callTimeout" value="2000" />
            <prop key="jms.initialConnectAttempts" value="3" />
            <!-- Properties needed by pooled-jms-specific org.ops4j.pax.jms.service.PooledConnectionFactoryFactory -->
            <prop key="pool.maxConnections" value="10" />
            <prop key="pool.idleTimeout" value="10000" />
        </props>
    </argument>
</bean>

<!--
    Expose connection factory to use by application code (like Camel, Spring, ...)
-->
<service interface="javax.jms.ConnectionFactory" ref="pool">
    <service-properties>
        <!-- Giving connection factory a name using one of these properties makes identification easier in jms:connectionfactories: -->
        <entry key="osgi.jndi.service.name" value="jms/artemis" />
        <!--<entry key="name" value="jms/artemis" />-->
        <!-- Without any of the above, name will fallback to "service.id" -->
    </service-properties>
</service>
----

In the above example, we use _factory_ beans that create connection factories using connection factory factories (...).
We don't need explicit reference to `javax.transaction.TransactionManager` service, as this is tracked
internally by XA-aware `PooledConnectionFactoryFactory`.

Here's how it looks like in Fuse/Karaf shell:

[listing,options="nowrap"]
----
karaf@root()> feature:install jms pax-jms-artemis pax-jms-pool-pooledjms

karaf@root()> install -s blueprint:file://$PQ_HOME/message-brokers/blueprints/artemis-pax-jms-factory-pooledjms.xml
Bundle ID: 264
karaf@root()> bundle:services -p 264

Bundle 264 provides:
--------------------
objectClass = [javax.jms.ConnectionFactory]
osgi.jndi.service.name = jms/artemis
osgi.service.blueprint.compname = pool
service.bundleid = 264
service.id = 265
service.scope = bundle
- - - -
objectClass = [org.osgi.service.blueprint.container.BlueprintContainer]
osgi.blueprint.container.symbolicname = artemis-pax-jms-factory-pooledjms.xml
osgi.blueprint.container.version = 0.0.0
service.bundleid = 264
service.id = 266
service.scope = singleton

karaf@root()> jms:connectionfactories
JMS Connection Factory
──────────────────────
jms/artemis

karaf@root()> jms:connectionfactories
JMS Connection Factory
──────────────────────
jms/artemis
karaf@root()> jms:info -u fuse -p fuse jms/artemis
Property │ Value
─────────┼──────────────────────────
product  │ ActiveMQ
version  │ 2.4.0.amq-711002-redhat-1
----

As shown in the above listing, blueprint bundle exports `javax.jms.ConnectionFactory` service which
is generic, non broker-specific connection pool.
The broker-specific `javax.jms.XAConnectionFactory` is *not* registered as OSGi service, because Blueprint
XML doesn't have explicit `<service ref="artemis">` declaration.

=== Mixed deployment of connection factories

`pax-jms-config` 1.0.0 adds another way of _wrapping_ broker-specific connection factories within pooling
connection factories using service properties. This method matches the way it used to work in Fuse 6.x.

Here's the Blueprint XML example:

[source,xml,options="nowrap"]
----
    <!--
        Broker-specific, non-pooling, non-enlisting javax.jms.XAConnectionFactory
    -->
    <bean id="artemis" class="org.apache.activemq.artemis.jms.client.ActiveMQXAConnectionFactory">
        <argument value="tcp://localhost:61616" />
        <property name="callTimeout" value="2000" />
        <property name="initialConnectAttempts" value="3" />
    </bean>

    <!--
        Expose broker-specific connection factory with service properties
        No need to expose pooling, enlisting, non broker-specific javax.jms.XAConnectionFactory - it'll be registered
        automatically by pax-jms-config with the same properties as this <service>, but with higher service.ranking
    -->
    <service id="pool" ref="artemis" interface="javax.jms.XAConnectionFactory">
        <service-properties>
            <!-- "pool" key is needed for pax-jms-config to wrap broker-specific connection factory inside connection pool -->
            <entry key="pool" value="pooledjms" />
            <!-- <service>/@id attribute doesn't propagate, but name of the connection factory is required using one of: -->
            <entry key="osgi.jndi.service.name" value="jms/artemis" />
            <!-- or: -->
            <!--<entry key="name" value="jms/artemis" />-->
            <!-- Other properties, that normally by e.g., pax-jms-pool-pooledjms -->
            <entry key="pool.maxConnections" value="10" />
            <entry key="pool.idleTimeout" value="10000" />
        </service-properties>
    </service>
----

In the above example, we manually register only broker-specific connection factory. `pool=pooledjms` service property
is a hint for connection factory tracker managed by `pax-jms-config` bundle. Connection Factory services with this service property
will be wrapped within pooling connection factory (in this example - `pax-jms-pool-pooledjms`).

Here's how it looks like in Fuse/Karaf shell:

[listing,options="nowrap"]
----
karaf@root()> feature:install jms pax-jms-config pax-jms-artemis pax-jms-pool-pooledjms

karaf@root()> install -s blueprint:file://$PQ_HOME/message-brokers/blueprints/artemis-pax-jms-discovery.xml
Bundle ID: 262

karaf@root()> bundle:services -p 262

Bundle 262 provides:
--------------------
objectClass = [javax.jms.XAConnectionFactory]
osgi.jndi.service.name = jms/artemis
osgi.service.blueprint.compname = artemis
pool = pooledjms
pool.idleTimeout = 10000
pool.maxConnections = 10
service.bundleid = 262
service.id = 265
service.scope = bundle
- - - -
objectClass = [org.osgi.service.blueprint.container.BlueprintContainer]
osgi.blueprint.container.symbolicname = artemis-pax-jms-discovery.xml
osgi.blueprint.container.version = 0.0.0
service.bundleid = 262
service.id = 267
service.scope = singleton

karaf@root()> service:list javax.jms.XAConnectionFactory
[javax.jms.XAConnectionFactory]
-------------------------------
 osgi.jndi.service.name = jms/artemis
 osgi.service.blueprint.compname = artemis
 pool = pooledjms
 pool.idleTimeout = 10000
 pool.maxConnections = 10
 service.bundleid = 262
 service.id = 265
 service.scope = bundle
Provided by :
 Bundle 262
Used by:
 OPS4J Pax JMS Config (259)

karaf@root()> service:list javax.jms.ConnectionFactory
[javax.jms.ConnectionFactory]
-----------------------------
 osgi.jndi.service.name = jms/artemis
 osgi.service.blueprint.compname = artemis
 pax.jms.managed = true
 pax.jms.service.id.ref = 265
 pool.idleTimeout = 10000
 pool.maxConnections = 10
 service.bundleid = 259
 service.id = 266
 service.ranking = 1000
 service.scope = singleton
Provided by :
 OPS4J Pax JMS Config (259)

karaf@root()> jms:connectionfactories
JMS Connection Factory
──────────────────────
jms/artemis

karaf@root()> jms:info -u fuse -p fuse jms/artemis
Property │ Value
─────────┼──────────────────────────
product  │ ActiveMQ
version  │ 2.4.0.amq-711002-redhat-1
----

This time, `jms:connectionfactories` shows only one service, but that's becuase this command removes duplicate names.

`javax.jms.XAConnectionFactory` is registered from the Blueprint bundle and have `pool = pooledjms` property declared.

`javax.jms.ConnectionFactory` is registered from `pax-jms-config` bundle and:

* doesn't have `pool = pooledjms` property (it was removed when registering wrapper connection factory)
* has `service.ranking = 1000` property, so it's always preferred version when e.g., looking for connection factory by name
* has `pax.jms.managed = true` property, so it's not tried to be wrapped again
* has `pax.jms.service.id.ref = 265` property, so we know what's the original connection factory service that's wrapped
inside connection pool

== Summary

I'm happy to reach the point, where both JDBC and JMS are handled consistently.